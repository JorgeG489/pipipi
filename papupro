print("sssasdasdasd")
local success, result = pcall(function()
    return loadstring(game:HttpGet('https://raw.githubusercontent.com/Kokiuvu123/GPO/refs/heads/main/sadsadsad'))()
end)

if not success or result ~= true then
    game.Players.LocalPlayer:Kick("script down")
    return
end

local player = game:GetService("Players").LocalPlayer

-- Separar la lógica en dos partes distintas
if game.PlaceId == 1730877806 then
    -- Primera parte: Esperar a que aparezca chooseType
    if getgenv().vipserver and getgenv().vipserver ~= "" then
        local priv = getgenv().vipserver
        print("vip server:" .. priv)
        
        task.spawn(function()
            -- Esperar a que el juego cargue completamente
            wait(3)
            
            -- Invocar el servidor privado hasta que aparezca chooseType
            while true do
                local chooseType = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("chooseType")
                
                if not chooseType then
                    print("sss?")
                    pcall(function()
                        game:GetService("ReplicatedStorage").Events.reserved:InvokeServer(priv)
                    end)
                    wait(2)
                else
                    print("yeahhhh!!")
                    break -- Salir del bucle cuando se encuentre chooseType
                end
            end
        end)
    end
end

-- Segunda parte: Activar el RemoteEvent una vez que chooseType exista
if game.PlaceId == 1730877806 then
    if getgenv().vipserver and getgenv().vipserver ~= "" then
        task.spawn(function()
            -- Esperar un poco para asegurar que la primera parte haya tenido tiempo de ejecutarse
            wait(5)
            
            -- Bucle para activar el RemoteEvent
            while true do
                local chooseType = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("chooseType")
                
                if chooseType then
                    print("11")
                    pcall(function()
                        local remoteEvent = chooseType.Frame:WaitForChild("RemoteEvent", 3)
                        if remoteEvent then
                            remoteEvent:FireServer(true)
                            print("2")
                            wait(5) -- Esperar más tiempo después de activar
                        else
                            print("4")
                        end
                    end)
                end
                
                wait(3) -- Verificar periódicamente
            end
        end)
    end
end



local MacLib = loadstring(game:HttpGet("https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt"))()

local Window = MacLib:Window({
	Title = "Ousi.HUB",
	Subtitle = "By (((koki)))",
	Size = UDim2.fromOffset(590, 470),
	DragStyle = 2,
	DisabledWindowControls = {},
	ShowUserInfo = true,
	Keybind = Enum.KeyCode.LeftControl,
	AcrylicBlur = true,
})

local globalSettings = {
	UIBlurToggle = Window:GlobalSetting({
		Name = "UI Blur",
		Default = Window:GetAcrylicBlurState(),
		Callback = function(bool)
			Window:SetAcrylicBlurState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
				Lifetime = 5
			})
		end,
	}),
	NotificationToggler = Window:GlobalSetting({
		Name = "Notifications",
		Default = Window:GetNotificationsState(),
		Callback = function(bool)
			Window:SetNotificationsState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " Notifications",
				Lifetime = 5
			})
		end,
	}),
	ShowUserInfo = Window:GlobalSetting({
		Name = "Show User Info",
		Default = Window:GetUserInfoState(),
		Callback = function(bool)
			Window:SetUserInfoState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Showing" or "Redacted") .. " User Info",
				Lifetime = 5
			})
		end,
	})
}



local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local activeTweens = {}
local questTweens = {} -- Nueva tabla para rastrear tweens específicos de misiones
local originalTweenCreate = TweenService.Create
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local runService = game:GetService("RunService")
local playerPos = player.Character.HumanoidRootPart.Position
local hRP = player.Character.HumanoidRootPart


local rifleStatusParagraph
local activeBodyVelocity = nil
local lastKeyCheck = 0
local keyDetected = false
local failedTargets = {}
local wave1GiftStabilizationTime = 0
local wave1LastGiftCount = 0
local wave1StableGiftCount = false
local colorTargets = {"Really blue", "Lime green", "Really red", "New Yeller"}

local debug = false
local farm = false
local wave = 1
local waveParagraph
local vim = cloneref(Instance.new("VirtualInputManager"))
local wave3EnemyStabilized = false
local enemigosPreviosCount = 0

local doWave1, doWave2, doWave3, doWave4, doWave5

local wavePositions = {
    [1] = {
        [1] = Vector3.new(-2035, 9, -14),  -- Ajusta estas coordenadas a las posiciones reales
    },
    [2] = {
        [1] = Vector3.new(-2325, 19, -12),  -- Ajusta estas coordenadas
        [2] = Vector3.new(-2336, 19, 112),
        ["Really blue"] = Vector3.new(-2381, 24, 76),
        ["Lime green"] = Vector3.new(-2369, 23, -33),
        ["Really red"] = Vector3.new(-2308, 21, 165),
        ["New Yeller"] = Vector3.new(-2381, 13, 259)
    },
    [3] = {
        [1] = Vector3.new(-2549, 19, 107), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-2547, 26, 63),
        [3] = Vector3.new(-2577, 27, -18),
        [4] = Vector3.new(-2647, 43, -15),
        [5] = Vector3.new(-2788, 42, -24),
        [6] = Vector3.new(-2970, 120, -21),
        [7] = Vector3.new(-2960, 130, 18)
    },
    [4] = {
        [1] = Vector3.new(-2965, 124, -23), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-3068, 125, -17),
        [3] = Vector3.new(-3194, 118, -20)
    },
    [5] = {
        [1] = Vector3.new(-3747, 99, -25),
        [2] = Vector3.new(-3862, 100, -20),
        [3] = Vector3.new(-4025, 48, -25),
        [4] = Vector3.new(-4331, 175, -24)
    }
}


local processedGifts = {}

local rifleEquipped = false -- Añadir esta variable global al inicio del script
local lastEquipAttempt = 0
local equipAttempts = 0
local MAX_EQUIP_ATTEMPTS = 5 -- Máximo número de intentos

-- Añadir estas variables al principio del script, junto con las otras variables globales
local firstGiftFound = false -- Indica si ya se encontró el primer regalo
local lastGiftFound = 0
local noGiftDelay = 8 -- Segundos a esperar sin encontrar regalos antes de considerar que ya no hay más

-- Añadir estas variables al principio del script
local giftCollection = {} -- Tabla para almacenar los regalos accesibles
local lastNewGift = 0 -- Último momento en que se detectó un regalo nuevo accesible
local collectionPhase = false -- Indica si estamos en fase de recolección
local waitingForGifts = 3 -- Segundos a esperar sin nuevos regalos antes de empezar a recogerlos
local maxSafeHeight = 10 -- Altura máxima segura para evitar el anti-cheat

-- Añadir esta variable global al inicio del script
local wave3PositionReached = false -- Indica si ya se llegó a la posición final de Wave 3

-- Variables globales adicionales 
local autoShootConnection = nil -- Para almacenar la conexión del Heartbeat
local targetSearchCooldown = 0.5 -- Buscar objetivos cada 0.5 segundos en lugar de cada frame
local lastTargetSearch = 0

-- Añadir esta variable global para colores entregados
local deliveredColors = {
    ["Really blue"] = false,
    ["Lime green"] = false,
    ["Really red"] = false,
    ["New Yeller"] = false
}

-- Variables
local currentTarget = nil
local lastShot = 0
local isReloading = false
local targetMarker = nil
local heartbeatConnection = nil -- Variable para almacenar la conexión

local wavePositions = {
    [1] = {
        [1] = Vector3.new(-2035, 9, -14),  -- Ajusta estas coordenadas a las posiciones reales
    },
    [2] = {
        [1] = Vector3.new(-2325, 19, -12),  -- Ajusta estas coordenadas
        [2] = Vector3.new(-2336, 19, 112),
        ["Really blue"] = Vector3.new(-2381, 24, 76),
        ["Lime green"] = Vector3.new(-2369, 23, -33),
        ["Really red"] = Vector3.new(-2308, 21, 165),
        ["New Yeller"] = Vector3.new(-2381, 13, 259)
    },
    [3] = {
        [1] = Vector3.new(-2549, 19, 107), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-2547, 26, 63),
        [3] = Vector3.new(-2577, 27, -18),
        [4] = Vector3.new(-2647, 43, -15),
        [5] = Vector3.new(-2788, 42, -24),
        [6] = Vector3.new(-2970, 120, -21),
        [7] = Vector3.new(-2960, 130, 18)
    },
    [4] = {
        [1] = Vector3.new(-2965, 124, -23), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-3068, 125, -17),
        [3] = Vector3.new(-3194, 118, -20)
    },
    [5] = {
        [1] = Vector3.new(-3747, 99, -25),
        [2] = Vector3.new(-3862, 100, -20),
        [3] = Vector3.new(-4025, 48, -25),
        [4] = Vector3.new(-4331, 200, -24)
    }
}


local processedGifts = {}

local rifleEquipped = false -- Añadir esta variable global al inicio del script
local lastEquipAttempt = 0
local equipAttempts = 0
local MAX_EQUIP_ATTEMPTS = 5 -- Máximo número de intentos

-- Añadir estas variables al principio del script, junto con las otras variables globales
local firstGiftFound = false -- Indica si ya se encontró el primer regalo
local lastGiftFound = 0
local noGiftDelay = 8 -- Segundos a esperar sin encontrar regalos antes de considerar que ya no hay más

-- Añadir estas variables al principio del script
local giftCollection = {} -- Tabla para almacenar los regalos accesibles
local lastNewGift = 0 -- Último momento en que se detectó un regalo nuevo accesible
local collectionPhase = false -- Indica si estamos en fase de recolección
local waitingForGifts = 3 -- Segundos a esperar sin nuevos regalos antes de empezar a recogerlos
local maxSafeHeight = 10 -- Altura máxima segura para evitar el anti-cheat

-- Añadir esta variable global al inicio del script
local wave3PositionReached = false -- Indica si ya se llegó a la posición final de Wave 3

-- Variables globales adicionales 
local autoShootConnection = nil -- Para almacenar la conexión del Heartbeat
local targetSearchCooldown = 0.5 -- Buscar objetivos cada 0.5 segundos en lugar de cada frame
local lastTargetSearch = 0

-- Añadir esta variable global para colores entregados
local deliveredColors = {
    ["Really blue"] = false,
    ["Lime green"] = false,
    ["Really red"] = false,
    ["New Yeller"] = false
}

-- Variables
local currentTarget = nil
local lastShot = 0
local isReloading = false
local targetMarker = nil
local heartbeatConnection = nil -- Variable para almacenar la conexión
local waveStartTime = 0
local waveTimeout = 300

local function equipWeapon(weapon)
    local success, result = pcall(function()
        -- Create VirtualInputManager if not already created
        
        local hotbar = game:GetService("Players").LocalPlayer.PlayerGui.BackpackGui.Hotbar
        if not hotbar then
            if debug then
                print("Hotbar no encontrado")
            end
            return false
        end
        
        local slotNames = {"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"}
        local keyMapping = {
            Zero = Enum.KeyCode.Zero,
            One = Enum.KeyCode.One,
            Two = Enum.KeyCode.Two,
            Three = Enum.KeyCode.Three,
            Four = Enum.KeyCode.Four,
            Five = Enum.KeyCode.Five,
            Six = Enum.KeyCode.Six,
            Seven = Enum.KeyCode.Seven,
            Eight = Enum.KeyCode.Eight,
            Nine = Enum.KeyCode.Nine
        }
        
        for i, slotName in ipairs(slotNames) do
            local slot = hotbar:FindFirstChild(slotName)
            if slot and slot:FindFirstChild(weapon) then
                -- Use VirtualInputManager to simulate key press
                pcall(function()
                    -- Send key down event
                    vim:SendKeyEvent(true, keyMapping[slotName], false, game)
                    task.wait(0.1)
                    -- Send key up event
                    vim:SendKeyEvent(false, keyMapping[slotName], false, game)
                end)
                
                return true
            end
        end
        
        if debug then
            print("Arma '" .. weapon .. "' no encontrada en el hotbar")
        end
        return false
    end)
    
    if not success then
        if debug then
            print("Error al equipar arma: " .. tostring(result))
        end
        return false
    end
    
    return result
end

task.spawn(function()
    game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
        if child.Name == 'ErrorPrompt' then
            task.spawn(function()
                TeleportService:Teleport(3978370137, game.Players.LocalPlayer)
            end)
        end
    end)
    
    -- Improved wave timeout check
    while true do
        wait(5) -- Check every 5 seconds
        if farm and waveStartTime > 0 then
            local timeInWave = tick() - waveStartTime
            if timeInWave > waveTimeout then
                if debug then
                    print("⚠️ Wave timeout reached! (" .. math.floor(timeInWave) .. " seconds) Teleporting back to lobby...")
                end
                
                -- Force teleport after timeout
                task.spawn(function()
                    TeleportService:Teleport(3978370137, game.Players.LocalPlayer)
                end)
                break
            elseif debug and timeInWave > (waveTimeout - 60) then
                -- Warning when approaching timeout
                print("⚠️ Wave timeout approaching! " .. math.floor(waveTimeout - timeInWave) .. " seconds remaining")
            end
        end
    end
end)


    
    
    -- Función para obtener la posición de un objeto
    local function getObjectPosition(object)
        if not object then
            return nil
        end
    
        if object:IsA("Model") and object.PrimaryPart then
            return object.PrimaryPart.Position
        elseif object:IsA("BasePart") then
            return object.Position
        else
            for _, child in pairs(object:GetDescendants()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        return nil
    end
    
    local function equipItem(item)
        local args = {
            [1] = "equip",
            [2] = item
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Tools"):InvokeServer(unpack(args))
        
    end
    
    
    
    local function getAllGifts()
        local gifts = {}
        
        -- Verificar que tenemos personaje y posición
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return gifts -- Devolver lista vacía si no hay personaje
        end
        
        local playerPos = player.Character.HumanoidRootPart.Position
        local minDistance = 500 -- Radio de búsqueda
        
        -- Método 1: Buscar directamente en workspace por YearGift
        pcall(function()
            -- Buscar en la ruta más común de los regalos
            local success, presentModels = pcall(function()
                return workspace.Islands["Anniversary 2023"].AreaInfo.Lobby.Environment.Assets.Presents
            end)
            
            if success and presentModels then
                if debug then
                    print("Buscando regalos en: " .. presentModels:GetFullName() .. " (" .. #presentModels:GetChildren() .. " elementos)")
                end
                
                for _, gift in pairs(presentModels:GetChildren()) do
                    if gift and gift.Name == "YearGift" then
                        local giftPos = getObjectPosition(gift)
                        if giftPos then
                            local distance = (giftPos - playerPos).Magnitude
                            if distance < minDistance then
                                table.insert(gifts, gift)
                                if debug then print("Regalo YearGift encontrado en ruta común") end
                            end
                        end
                    end
                end
            end
        end)
        
        -- Método 2: Buscar específicamente en Effects.PresentModels si existe
        pcall(function()
            if workspace:FindFirstChild("Effects") and workspace.Effects:FindFirstChild("PresentModels") then
                for _, gift in pairs(workspace.Effects.PresentModels:GetChildren()) do
                    if gift and gift.Name == "YearGift" then
                        local giftPos = getObjectPosition(gift)
                        if giftPos then
                            local distance = (giftPos - playerPos).Magnitude
                            if distance < minDistance then
                                local duplicate = false
                                for _, existingGift in ipairs(gifts) do
                                    if existingGift and getObjectPosition(existingGift) and
                                       (getObjectPosition(existingGift) - giftPos).Magnitude < 5 then
                                        duplicate = true
                                        break
                                    end
                                end
                                
                                if not duplicate then
                                    table.insert(gifts, gift)
                                    if debug then
                                        print("Regalo YearGift encontrado en Effects.PresentModels: " .. gift:GetFullName())
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        
        -- Método 3: Buscar YearGift en todo el workspace como último recurso
        -- SOLO busca objetos con el nombre EXACTO "YearGift"
        pcall(function()
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj.Name == "YearGift" then  -- SOLO nombre exacto
                    local giftPos = getObjectPosition(obj)
                    if giftPos then
                        local distance = (giftPos - playerPos).Magnitude
                        if distance < minDistance then
                            -- Verificar si ya está en la lista
                            local duplicate = false
                            for _, existingGift in ipairs(gifts) do
                                if existingGift and getObjectPosition(existingGift) and
                                   (getObjectPosition(existingGift) - giftPos).Magnitude < 5 then
                                    duplicate = true
                                    break
                                end
                            end
                            
                            if not duplicate then
                                table.insert(gifts, obj)
                                if debug then
                                    print("Regalo YearGift encontrado en workspace: " .. obj:GetFullName())
                                end
                            end
                        end
                    end
                end
            end
        end)
        
        if debug then
            print("Total de YearGifts encontrados: " .. #gifts)
        end
        
        return gifts
    end
    
    
    
    
    
    --[[
    
    wave 1 function
    
    
    ]]--
    local function setupBodyVelocity()
        -- Limpiar cualquier BodyVelocity existente primero
        if activeBodyVelocity then
            pcall(function() activeBodyVelocity:Destroy() end)
            activeBodyVelocity = nil
        end
        
        -- Verificar que tenemos acceso al personaje y HumanoidRootPart
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Crear nuevo BodyVelocity
            activeBodyVelocity = Instance.new("BodyVelocity")
            activeBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            activeBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            activeBodyVelocity.Parent = player.Character.HumanoidRootPart
        else
            if debug then
                print("Error en setupBodyVelocity: HumanoidRootPart no disponible")
            end
        end
    end
    
    -- Función para limpiar el BodyVelocity
    local function clearBodyVelocity()
        if activeBodyVelocity then
            pcall(function() activeBodyVelocity:Destroy() end)
            activeBodyVelocity = nil
        end
    end
    
    local function key()
        -- Solo verificar cada cierto intervalo para no sobrecargar
        if tick() - lastKeyCheck < 1 then
            return keyDetected
        end
        
        -- Actualizar el tiempo de la última verificación
        lastKeyCheck = tick()
        
        -- Usar pcall para evitar errores si la ruta no existe
        local success, result = pcall(function()
            return workspace.Islands["Anniversary 2023"].AreaInfo.KeyFinder.Environment.Key ~= nil
        end)
        
        -- Si se encontró la Key y es un MeshPart
        if success and result then
            local keyPart = workspace.Islands["Anniversary 2023"].AreaInfo.KeyFinder.Environment.Key
            
            -- Verificar que sea un MeshPart
            if keyPart and keyPart:IsA("MeshPart") then
                if debugMode then
                    print("🔑 KEY DETECTADA: Confirmación de Wave 2")
                end
                
                keyDetected = true
                return true
            end
        end
        
        -- No se encontró la Key
        return false
    end
    
    local function tween(position, disableAutoInteract)
        if not position then 
            if debug then
                print("Error: tween llamado con posición nula")
            end
            return false 
        end
        
        -- Asegurarse de que tengamos acceso al personaje
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if debug then
                print("Error: HumanoidRootPart no disponible")
            end
            return false
        end
        
        local rootPart = player.Character.HumanoidRootPart
        
        -- Configurar BodyVelocity de forma simple
        pcall(function() 
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
            end
            activeBodyVelocity = Instance.new("BodyVelocity")
            activeBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            activeBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            activeBodyVelocity.Parent = rootPart
        end)
        
        -- Elevar ligeramente para evitar obstáculos
        rootPart.CFrame = CFrame.new(rootPart.Position.x, rootPart.Position.y + 15, rootPart.Position.z)
        
        
        -- Calcular distancia y tiempo
        local distance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia al objetivo: " .. distance) end
        
        -- Máxima velocidad
        local velocidad = 60 -- Velocidad moderada para mayor precisión
        local tweenInfo = TweenInfo.new(
            distance / velocidad,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.Out
        )
        
        -- Ejecutar tween con una flag de completado
        local tweenCompleted = false
        pcall(function()
            local tweenInstance = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(position)})
            
            -- Conectar evento de completado
            tweenInstance.Completed:Connect(function()
                tweenCompleted = true
                if debug then print("Tween completado totalmente") end
            end)
            
            tweenInstance:Play()
            
    
            
            -- Esperar a que termine el tween completamente
            local startTime = tick()
            local timeout = (distance / velocidad) + 1 -- Añadir 1 segundo de margen
            
            while not tweenCompleted and (tick() - startTime) < timeout do
                wait(0.1)
            end
            
            if not tweenCompleted then
                if debug then print("Tween no se completó en el tiempo esperado, pero continuamos") end
            end
        end)
        
        -- Solo interactuar si se solicita
        if not disableAutoInteract then
            -- Interactuar una sola vez con el prompt más cercano
            pcall(function()
                local closestPrompt = nil
                local minDistance = 5
                
                for _, prompt in pairs(workspace:GetDescendants()) do
                    if prompt:IsA("ProximityPrompt") and prompt.Enabled then
                        local parent = prompt.Parent
                        if parent and parent:IsA("BasePart") then
                            local promptDistance = (parent.Position - rootPart.Position).Magnitude
                            if promptDistance < minDistance then
                                minDistance = promptDistance
                                closestPrompt = prompt
                            end
                        end
                    end
                end
                
                if closestPrompt then
                        fireproximityprompt(closestPrompt)
    
                    
                    
                    if debug then print("Interactuando con prompt") end
                end
            end)
        end
        
        -- Limpiar BodyVelocity inmediatamente
        pcall(function()
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
                activeBodyVelocity = nil
            end
        end)
        
        -- Verificar la distancia final para determinar si llegamos con precisión
        local finalDistance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia final al objetivo: " .. finalDistance) end
        
        -- Considerar exitoso si estamos lo suficientemente cerca
        return finalDistance < 5
    end
    
    
    local function tweenwave4(position, disableAutoInteract)
        if not position then 
            if debug then
                print("Error: tween llamado con posición nula")
            end
            return false 
        end
        
        -- Asegurarse de que tengamos acceso al personaje
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if debug then
                print("Error: HumanoidRootPart no disponible")
            end
            return false
        end
        
        local rootPart = player.Character.HumanoidRootPart
        
        -- Configurar BodyVelocity de forma simple
        pcall(function() 
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
            end
            activeBodyVelocity = Instance.new("BodyVelocity")
            activeBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            activeBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            activeBodyVelocity.Parent = rootPart
        end)
        
        -- Elevar ligeramente para evitar obstáculos
        rootPart.CFrame = CFrame.new(rootPart.Position.x, rootPart.Position.y + 3, rootPart.Position.z)
        
        -- Calcular distancia y tiempo
        local distance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia al objetivo: " .. distance) end
        
        -- Máxima velocidad
        local velocidad = 35 -- Velocidad moderada para mayor precisión
        local tweenInfo = TweenInfo.new(
            distance / velocidad,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.Out
        )
        
        -- Ejecutar tween con una flag de completado
        local tweenCompleted = false
        pcall(function()
            local tweenInstance = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(position)})
            
            -- Conectar evento de completado
            tweenInstance.Completed:Connect(function()
                tweenCompleted = true
                if debug then print("Tween completado totalmente") end
            end)
            
            tweenInstance:Play()
            
            -- Esperar a que termine el tween completamente
            local startTime = tick()
            local timeout = (distance / velocidad) + 1 -- Añadir 1 segundo de margen
            
            while not tweenCompleted and (tick() - startTime) < timeout do
                wait(0.1)
            end
            
            if not tweenCompleted then
                if debug then print("Tween no se completó en el tiempo esperado, pero continuamos") end
            end
        end)
        
        -- Solo interactuar si se solicita
        if not disableAutoInteract then
            -- Interactuar una sola vez con el prompt más cercano
            pcall(function()
                local closestPrompt = nil
                local minDistance = 5
                
                for _, prompt in pairs(workspace:GetDescendants()) do
                    if prompt:IsA("ProximityPrompt") and prompt.Enabled then
                        local parent = prompt.Parent
                        if parent and parent:IsA("BasePart") then
                            local promptDistance = (parent.Position - rootPart.Position).Magnitude
                            if promptDistance < minDistance then
                                minDistance = promptDistance
                                closestPrompt = prompt
                            end
                        end
                    end
                end
                
                if closestPrompt then
                    for i = 1, 6 do
                        fireproximityprompt(closestPrompt)
                    end
                    
                    
                    if debug then print("Interactuando con prompt") end
                end
            end)
        end
        
        -- Limpiar BodyVelocity inmediatamente
        pcall(function()
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
                activeBodyVelocity = nil
            end
        end)
        
        -- Verificar la distancia final para determinar si llegamos con precisión
        local finalDistance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia final al objetivo: " .. finalDistance) end
        
        -- Considerar exitoso si estamos lo suficientemente cerca
        return finalDistance < 5
    end
    
    local function nearesrGift()
        -- Verificar si el jugador y su personaje están disponibles
        if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if debug then
                print("Error: El personaje o HumanoidRootPart no está disponible")
            end
            return {}
        end
        
        -- Posición del jugador
        local posicionJugador = player.Character.HumanoidRootPart.Position
        
        -- Tabla para almacenar los regalos encontrados
        local regalosCercanos = {}
        
        -- Intentar encontrar los regalos usando pcall para evitar errores
        local exito, errorMensaje = pcall(function()
            -- Verificar que exista la ruta a los regalos
            if workspace.Effects and workspace.Effects.PresentModels then
                -- Buscar todos los regalos del año
                for _, regalo in pairs(workspace.Effects.PresentModels:GetChildren()) do
                    -- Verificar si es un regalo del año
                    if regalo.Name:match("YearGift") then
                        -- Obtener la posición del regalo
                        local posicionRegalo = getObjectPosition(regalo)
                        
                        if posicionRegalo then
                            -- Calcular la distancia entre el jugador y el regalo
                            local distancia = (posicionRegalo - posicionJugador).Magnitude
                            
                            -- Agregar el regalo a la tabla con su distancia
                            table.insert(regalosCercanos, {
                                regalo = regalo,
                                distancia = distancia,
                                posicion = posicionRegalo
                            })
                            
                            if debug then
                                print("Regalo encontrado a distancia: " .. distancia)
                            end
                        end
                    end
                end
            else
                if debug then
                    print("No se encontró la ruta workspace.Effects.PresentModels")
                end
            end
        end)
        
        if not exito and debug then
            print("Error al buscar regalos: " .. tostring(errorMensaje))
        end
        
        -- Ordenar los regalos por distancia (más cercanos primero)
        table.sort(regalosCercanos, function(a, b)
            return a.distancia < b.distancia
        end)
        
        return regalosCercanos
    end
    
    
    local function gotoWavePosition(waveNumber, positionNumber)
        -- Verificaciones de seguridad más robustas
        if type(waveNumber) ~= "number" or type(positionNumber) ~= "number" then
            if debug then
                print("Error: Números de wave o posición inválidos")
            end
            return false
        end
        
        if not wavePositions[waveNumber] then
            if debug then
                print("Error: Wave " .. waveNumber .. " no tiene posiciones definidas")
            end
            return false
        end
        
        if not wavePositions[waveNumber][positionNumber] then
            if debug then
                print("Error: Posición " .. positionNumber .. " no definida para Wave " .. waveNumber)
            end
            return false
        end
        
        local targetPosition = wavePositions[waveNumber][positionNumber]
        
        if debug then
            print("Moviendo a posición " .. positionNumber .. " de Wave " .. waveNumber .. ": " .. tostring(targetPosition))
        end
        
        -- Usar nuestra función tween para moverse
        return tween(targetPosition, false)
    end
    
    
    
    
    
    -- Add this variable at the top of your script with the other global variables
    local processedGiftsWave1 = {}
    
    -- Then modify the doWave1 function
    -- Modify the doWave1 function to avoid repeated stabilization waits
    doWave1 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        -- Verificar primero si ha aparecido la key
        if key() then
            wave = 2
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 2!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio automático",
                Description = "¡Key detectada! Cambiando a Wave 2",
                Lifetime = 3
            })
        end
    
            wait(1)
            gotoWavePosition(1, 1)
            gotoWavePosition(2, 1)
            return true -- Indicar cambio de wave
        end
    
        -- Buscar regalos cercanos
        local gifts = nearesrGift()
        
        -- NUEVA LÓGICA: Detectar cuando los regalos se han estabilizado
        if #gifts > 0 then
            -- Si el número de regalos ha cambiado significativamente (más de 2 nuevos regalos), reiniciar el temporizador
            -- Solo si aún no hemos comenzado a recoger regalos
            if wave1LastGiftCount > 0 and (#gifts - wave1LastGiftCount) > 2 and #processedGiftsWave1 == 0 then
                if debug then
                    print("Número de regalos aumentó significativamente: " .. wave1LastGiftCount .. " -> " .. #gifts)
                end
                wave1LastGiftCount = #gifts
                wave1GiftStabilizationTime = tick()
                wave1StableGiftCount = false
            -- Si es la primera vez que vemos regalos o hay un cambio normal
            elseif wave1LastGiftCount ~= #gifts and not wave1StableGiftCount then
                if debug then
                    print("Número de regalos cambió: " .. wave1LastGiftCount .. " -> " .. #gifts)
                end
                wave1LastGiftCount = #gifts
                wave1GiftStabilizationTime = tick()
            -- Si ya estamos en proceso de recolección, no reiniciar la estabilización
            elseif not wave1StableGiftCount and #processedGiftsWave1 == 0 then
                -- Si el número de regalos no ha cambiado durante 3 segundos, considerarlos estables
                if (tick() - wave1GiftStabilizationTime) > 3 then
                    wave1StableGiftCount = true
                    if debug then
                        print("Regalos estabilizados: " .. #gifts .. " regalos detectados")
                    end
                    if debug then
                        Window:Notify({
                        Title = "Regalos estabilizados",
                        Description = "Comenzando recolección de " .. #gifts .. " regalos",
                        Lifetime = 2
                    })
                end
                    -- Reiniciar la lista de regalos procesados para recogerlos todos
                    processedGiftsWave1 = {}
                else
                    if debug then
                        print("Esperando estabilización de regalos: " .. math.floor(tick() - wave1GiftStabilizationTime) .. "/3 segundos")
                    end
                    wait(0.5) -- Esperar mientras se estabilizan
                    return false
                end
            end
        else
            -- Si no hay regalos y no estamos en proceso de recolección, reiniciar el estado
            if #processedGiftsWave1 == 0 then
                wave1LastGiftCount = 0
                wave1StableGiftCount = false
            end
            wait(0.5)
            return false
        end
        
        -- Solo proceder a esperar estabilización si no hemos comenzado a recoger regalos
        if not wave1StableGiftCount and #processedGiftsWave1 == 0 then
            wait(0.5)
            return false
        end
    
        -- A partir de aquí, la lógica es similar a la original pero solo se ejecuta cuando los regalos están estabilizados
        -- o ya hemos comenzado a recoger regalos
        local validGift = nil
        
        -- Buscar un regalo que no haya sido procesado aún
        for _, gift in ipairs(gifts) do
            local giftId = tostring(gift.posicion)
            if not processedGiftsWave1[giftId] then
                validGift = gift
                break
            end
        end
    
        if validGift then
            local giftId = tostring(validGift.posicion)
            
            -- Marcar este regalo como procesado antes de moverse a él
            processedGiftsWave1[giftId] = true
            
            if debug then
                print("Yendo a regalo en posición: " .. giftId)
            end
            
            -- Ir al regalo e interactuar
            tween(validGift.posicion, false)
            
            -- Verificar key inmediatamente
            if key() then
                wave = 2
                if waveParagraph then
                    waveParagraph:UpdateBody("Wave 2!")
                end
    
                gotoWavePosition(1, 1)
                gotoWavePosition(2, 1)
                return true -- Cambiar a Wave 2 inmediatamente
            end
            
            -- No wait here - continue to next gift immediately
            return false
        else
            -- Si todos los regalos visibles ya fueron procesados, limpiar la lista
            -- para permitir que se procesen nuevamente en caso de que aparezcan nuevos
            if #gifts > 0 then
                processedGiftsWave1 = {}
                if debug then
                    print("Reiniciando lista de regalos procesados")
                end
            end
            
            -- Si no hay regalos, esperar un tiempo mínimo
            wait(0.05)
            return false
        end
    end
    
    
    --[[
    
    wave 2 function
    
    
    ]]--
    
    local function getGiftColor(gift)
        if not gift or not gift:IsA("Model") then return nil end
        
        -- Usar pcall para evitar errores
        local success, color = pcall(function()
            -- Primer intento: buscar el patrón estándar Bottom -> ColorStrip
            local colorStrip = gift:FindFirstChild("Bottom") and gift.Bottom:FindFirstChild("ColorStrip")
            if colorStrip and colorStrip:IsA("BasePart") then
                return tostring(colorStrip.BrickColor)
            end
            
            -- Segundo intento: buscar ColorStrip en cualquier parte del regalo
            local foundColorStrip = gift:FindFirstDescendant("ColorStrip")
            if foundColorStrip and foundColorStrip:IsA("BasePart") then
                return tostring(foundColorStrip.BrickColor)
            end
            
            -- Tercer intento: buscar cualquier parte con un color que no sea gris
            for _, part in pairs(gift:GetDescendants()) do
                if part:IsA("BasePart") then
                    local partColor = tostring(part.BrickColor)
                    if partColor ~= "Medium stone grey" and partColor ~= "Light stone grey" then
                        return partColor
                    end
                end
            end
            
            return nil
        end)
        
        return success and color or nil
    end
    
    local function normalizeColor(color)
        -- Normalizar nombres de colores
        if typeof(color) ~= "string" then return nil end
        
        -- Convertir a minúsculas para comparación
        local lowerColor = string.lower(color)
        
        -- Mapear variantes de nombres de colores a los colores estándar
        if string.find(lowerColor, "blue") or string.find(lowerColor, "azul") then
            return "Really blue"
        elseif string.find(lowerColor, "green") or string.find(lowerColor, "verde") then
            return "Lime green"
        elseif string.find(lowerColor, "red") or string.find(lowerColor, "rojo") then
            return "Really red"
        elseif string.find(lowerColor, "yellow") or string.find(lowerColor, "amarillo") or string.find(lowerColor, "yeller") then
            return "New Yeller"
        end
        
        -- Si es un color estándar, devolverlo tal cual
        if color == "Really blue" or color == "Lime green" or color == "Really red" or color == "New Yeller" then
            return color
        end
        
        -- No pudo normalizarse
        return nil
    end
    
    local function isColorDelivered(color)
        if not color then return false end
        
        -- Normalizar el color por si acaso
        local normalizedColor = normalizeColor(color)
        if not normalizedColor then return false end
        
        -- Verificar si el color está marcado como entregado
        return deliveredColors[normalizedColor] == true
    end
    
    local function markColorAsDelivered(color)
        -- Normalizar el color
        local normalizedColor = normalizeColor(color)
        if normalizedColor and deliveredColors[normalizedColor] ~= nil then
            deliveredColors[normalizedColor] = true
            if debug then
                print("✅ Color " .. normalizedColor .. " marcado como entregado")
            end
            return true
        end
        return false
    end
    
    -- Función para el control de Wave 2
    doWave2 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        if debug then
            print("Ejecutando lógica de Wave 2")
        end
    
        -- Actualizar la posición del jugador siempre al inicio
        playerPos = player.Character.HumanoidRootPart.Position
        
        -- Verificar si todos los colores han sido entregados
        local todosProcesados = true
        for color, entregado in pairs(deliveredColors) do
            if not entregado then
                todosProcesados = false
                break
            end
        end
        
        if todosProcesados then
            if debug then print("¡Todos los colores entregados! Pasando a Wave 3") end
            wave = 3
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 3!")
            end
            wait(1)
            return true
        end
    
        -- Ir primero a la posición base antes de buscar regalos
        if debug then print("Yendo a la posición base...") end
        gotoWavePosition(2, 2)
    
        local allGifts = getAllGifts()
        if debug then print("Encontrados " .. #allGifts .. " regalos en total") end
    
        local giftsToCollect = {}
        for _, gift in ipairs(allGifts) do
            local giftColor = getGiftColor(gift)
            if giftColor then
                local normalizedColor = normalizeColor(giftColor)
                if normalizedColor and not deliveredColors[normalizedColor] then
                    -- Obtener la posición del regalo correctamente
                    local giftPosition = getObjectPosition(gift)
                    
                    if giftPosition then -- Solo agregar si tiene posición válida
                        table.insert(giftsToCollect, {
                            objeto = gift,           -- Guardar el objeto para referencia
                            posicion = giftPosition, -- Guardar la posición como Vector3
                            color = normalizedColor
                        })
                        if debug then print("Regalo candidato: " .. normalizedColor) end
                    end
                end
            end
        end
    
        local closest = nil
        local minDist = math.huge
        
        for _, gift in ipairs(giftsToCollect) do
            local dist = (playerPos - gift.posicion).Magnitude
            if dist < minDist then
                minDist = dist
                closest = gift
            end
        end
    
        if closest then
            if debug then
                print("Recogiendo regalo " .. closest.color .. " a " .. math.floor(minDist) .. " distancia")
            end
            
            -- Moverse al regalo con varios intentos
            local moveSuccess = false
            
            -- Intento 1: tween normal
            if debug then print("Intento 1: Usando tween normal") end
            pcall(function() 
                moveSuccess = tween(closest.posicion) 
            end)
            
            -- Si falló, probar con teletransporte directo
            if not moveSuccess then
                if debug then print("Intento 2: Usando teletransporte directo") end
                pcall(function()
                    hRP.CFrame = CFrame.new(closest.posicion)
                    moveSuccess = true
                    wait(1) -- Esperar más tiempo para estabilizar
                end)
            end
            
            -- Esperar a recoger el regalo (más tiempo)
            wait(0.5)
            
            -- Entregar el regalo al lugar correcto según su color sin volver a la base
            local entregaExitosa = false
            
            -- Mapeo de colores a posiciones de entrega
            local entregaPositions = {
                ["Really blue"] = Vector3.new(-2381, 24, 78),
                ["Lime green"] = Vector3.new(-2369, 23, -33),
                ["Really red"] = Vector3.new(-2307, 21, 169),
                ["New Yeller"] = Vector3.new(-2382, 13, 261)
            }
            
            -- Posición para el color actual
            local deliveryPos = entregaPositions[closest.color]
            
            if deliveryPos then
                -- NUEVO: Verificar si es Lime green y está cerca de la posición especial
                local specialPosition = Vector3.new(-2506, 19, 107)
                local isNearSpecialPosition = false
                
                if closest.color == "Lime green" then
                    local distanceToSpecial = (closest.posicion - specialPosition).Magnitude
                    if distanceToSpecial <= 60 then
                        isNearSpecialPosition = true
                        if debug then
                            print("Regalo Lime green detectado cerca de posición especial: " .. math.floor(distanceToSpecial) .. " unidades")
                        end
                    end
                end
                
                -- Si es Lime green cerca de la posición especial, ir primero a la base
                if isNearSpecialPosition then
                    if debug then
                        print("Caso especial: Lime green cerca de posición especial, yendo primero a la base")
                    end
                    -- Modificado: Usar tween directamente con interacción desactivada en lugar de gotoWavePosition
                    local basePosition = wavePositions[2][2]
                    tween(basePosition, true) -- true para deshabilitar la interacción automática
                    wait(1)
                end
                if debug then
                    print("Entregando regalo " .. closest.color .. " a posición específica")
                end
    
                
                
                -- Intentos múltiples para asegurar la entrega
                local maxIntentos = 3
                local intentoActual = 0
                local deliverySuccess = false
                
                while not deliverySuccess and intentoActual < maxIntentos do
                    intentoActual = intentoActual + 1
                    
                    if debug then print("Intento " .. intentoActual .. " de entregar a posición") end
                    
                    -- Tween a la posición de entrega y verificar si se llegó correctamente
                    deliverySuccess = tween(deliveryPos)
                    
                    -- Si el tween reporta éxito
                    if deliverySuccess then
                        if debug then print("Llegamos a la posición de entrega exacta") end
                        
                        -- Esperar un momento para que se registre la entrega (más tiempo)
                        
                        -- Marcar como entregado manualmente
                        markColorAsDelivered(closest.color)
                        entregaExitosa = true
                        
                        -- Notificar al usuario
                        if debug then
                            Window:Notify({
                                Title = "Entrega exitosa",
                                Description = "Regalo " .. closest.color .. " entregado",
                                Lifetime = 3
                        })
                    end
                        
                        -- AHORA volver a la posición base después de entregar exitosamente un regalo
                        if debug then print("Volviendo a la posición base después de entregar...") end
                        gotoWavePosition(2, 2)
                        wait(1)
                        
                        break
                    else
                        if debug then print("Intento fallido, reintentando") end
                        wait(1) -- Esperar un poco antes de reintentar
                    end
                end
                
                -- Si no tuvimos éxito con los tweens, probar teletransporte directo
                if not deliverySuccess then
                    if debug then print("Intento final: Teletransporte directo a posición de entrega") end
                    pcall(function()
                        hRP.CFrame = CFrame.new(deliveryPos)-- Esperar más tiempo para que se registre la entrega
                        
                        -- Marcar como entregado manualmente
                        markColorAsDelivered(closest.color)
                        entregaExitosa = true
                        
                        -- Notificar al usuario
                        if debug then
                            Window:Notify({
                            Title = "Entrega con teletransporte",
                            Description = "Regalo " .. closest.color .. " entregado",
                            Lifetime = 3
                        })
                    end
                        
                        -- AHORA volver a la posición base después de entregar exitosamente un regalo
                        if debug then print("Volviendo a la posición base después de entregar...") end
                        gotoWavePosition(2, 2)
                        wait(1)
                    end)
                end
            else
                if debug then print("Error: No hay posición de entrega definida para " .. closest.color) end
                -- Volver a la posición base si no hay posición de entrega
                if debug then print("Volviendo a la posición base...") end
                gotoWavePosition(2, 2)
                wait(1)
            end
            
            -- Si la entrega falló después de todos los intentos
            if not entregaExitosa then
                if debug then print("⚠️ No se pudo entregar el regalo " .. closest.color .. " después de múltiples intentos") end
                
                -- Volver a la posición base incluso si falló la entrega
                if debug then print("Volviendo a la posición base...") end
                gotoWavePosition(2, 2)
                wait(1)
            end
        else
            if debug then print("No se encontró ningún regalo cercano") end
            wait(1)
        end
    
        wait(0.5) -- Reducir espera entre ciclos
        return false -- Seguir en Wave 2
    end
    
    
    
    --[[
    
    wave 3 
    
    
    ]]--
    
    local wave3 = false
    local wave3EnemyStabilized = false
    local enemigosPreviosCount = 0
    
    -- Variables locales para las posiciones estratégicas
    local posicionInicial = wavePositions[3][1]
    local posicionPrimaria = Vector3.new(-2680, 80, -126)
    local posicionIntermedia = Vector3.new(-2742, 39, -32)
    local posicionFinal = Vector3.new(-2551, 96, -73) 
    
    -- Estado de la secuencia (añadir esta variable global al inicio del script)
    local wave3SequenceState = nil
    
    -- Variables para detección de ausencia de OPEN ME
    local lastEnemyDetectedTime = nil
    
    -- Función para obtener instancias nil
    function getNil(name, class)
        -- Verificar primero si la función getnilinstances existe
        if not getnilinstances then
            if debug then
                print("La función getnilinstances no está disponible")
            end
            return nil
        end
        
        -- Envolver en pcall para evitar errores
        local success, instances = pcall(function()
            return getnilinstances()
        end)
        
        if not success or not instances then
            if debug then
                print("Error al obtener nil instances: " .. tostring(instances))
            end
            return nil
        end
        
        -- Buscar la instancia solicitada
        for _, v in pairs(instances) do
            if v and v.ClassName == class and v.Name == name then
                return v
            end
        end
        return nil -- Devolver nil explícitamente si no se encuentra
    end
    
    -- Configuración
    local config = {
        enabled = true, -- Siempre activado desde el inicio
        range = math.huge, -- Distancia infinita para atacar
        autoReload = true,
        checkRaycast = true, -- Desactivado para permitir disparar a través de obstáculos
        targetPart = "HumanoidRootPart", -- Parte del NPC a la que disparar
        visualizeTarget = false -- Crear un marcador visual para el objetivo
    }
    
    -- Crear marcador visual
    local function createTargetMarker()
        if targetMarker then return end
        
        targetMarker = Instance.new("Part")
        targetMarker.Anchored = true
        targetMarker.CanCollide = false
        targetMarker.Size = Vector3.new(0.5, 0.5, 0.5)
        targetMarker.Color = Color3.fromRGB(255, 0, 0)
        targetMarker.Material = Enum.Material.Neon
        targetMarker.Shape = Enum.PartType.Ball
        targetMarker.Transparency = 0.5
        targetMarker.Parent = workspace
    end
    
    -- Encontrar el bandido más cercano
    local function findOPENME()
        -- Usar pcall para todo el proceso
        local success, result = pcall(function()
            local closestDistance = config.range
            local closest = nil
            
            -- Verificar si workspace y NPCs existen
            if not workspace or not workspace:FindFirstChild("NPCs") then
                if debug then
                    print("workspace.NPCs no encontrado")
                end
                return nil
            end
            
            -- Limpiar objetivos fallidos antiguos (más de 10 segundos)
            local currentTime = tick()
            for targetId, failInfo in pairs(failedTargets) do
                -- Si han pasado más de 30 segundos o el objetivo ha recibido menos de 5 intentos
                if currentTime - failInfo.time > 30 or failInfo.attempts < 5 then
                    failedTargets[targetId] = nil
                
                -- Si el objetivo ha recibido más de 10 intentos, marcarlo como raycastOnly en lugar de eliminarlo
                elseif failInfo.attempts > 10 and not failInfo.raycastOnly then
                    -- Marcar como raycastOnly en lugar de eliminar
                    if debug then
                        print("Objetivo marcado como raycastOnly después de demasiados intentos: " .. targetId)
                    end
                    failedTargets[targetId].raycastOnly = true
                end
            end
    
            local specialPosition = Vector3.new(-2649, 38, -11)
            local specialRadius = 68
            
            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                    local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- Verificar si está en el radio especial
                            local distanceToSpecial = (targetPart.Position - specialPosition).Magnitude
                            if distanceToSpecial <= specialRadius then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                if distance < closestDistance then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                    if debug then
                                        print("Enemigo en zona especial encontrado a distancia: " .. distance)
                                    end
                                end
                            end
                        end
                    end
                end
            end
    
            -- Si no encontramos enemigos en la zona especial, continuar con la lógica normal
            if not closest then
                -- Primero buscar objetivos sin raycast y que no estén en la lista de fallidos
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                        local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                
                                -- Verificar si este objetivo está en la lista de fallidos
                                local targetId = tostring(npc:GetFullName())
                                local isFailed = failedTargets[targetId] ~= nil
                                local isRaycastOnly = isFailed and failedTargets[targetId].raycastOnly == true
                                
                                -- Comprobar si hay obstáculos mediante raycast
                                local canSee = true
                                local ray = Ray.new(player.Character.HumanoidRootPart.Position, targetPart.Position - player.Character.HumanoidRootPart.Position)
                                local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                canSee = hit == nil
                                
                                -- Priorizar objetivos sin raycast y que no estén marcados como raycastOnly
                                if distance < closestDistance and canSee and not isRaycastOnly then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                end
                            end
                        end
                    end
                end
            end
    
            if not closest and wave3State == "posicion_primaria" then
                closestDistance = config.range
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                        local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                
                                -- Verificar si este objetivo está marcado como raycastOnly
                                local targetId = tostring(npc:GetFullName())
                                local isRaycastOnly = failedTargets[targetId] and failedTargets[targetId].raycastOnly == true
                                
                                if distance < closestDistance and isRaycastOnly then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                end
                            end
                        end
                    end
                end
            end
            
            -- Si aún no encontramos ningún objetivo, buscar cualquier objetivo (incluso con raycast)
            if not closest and config.checkRaycast == false then
                closestDistance = config.range
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                        local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                
                                if distance < closestDistance then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                end
                            end
                        end
                    end
                end
            end
            
            return closest
        end)
        
        if not success then
            if debug then
                print("Error en findOPENME: " .. tostring(result))
            end
            return nil
        end
        
        return result
    end
    
    -- Recargar rifle
    local function reloadRifle()
        if isReloading then return end
        isReloading = true
        
        local args = {
            [1] = "reload",
            [2] = {
                ["Gun"] = "Rifle"
            }
        }
        
        local success = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("Events")
                :WaitForChild("CIcklcon"):WaitForChild("gunFunctions"):InvokeServer(unpack(args))
        end)
        
        isReloading = false
        return success
    end
    
    -- Disparar al objetivo
    local function shootTarget(target)
        if not target or not target.part then
            if debug then
                print("Target inválido para disparar")
            end
            return false
        end
        
        -- Verificar cooldown
        if tick() - lastShot < 0.5 then return false end
        lastShot = tick()
        
        -- Verificar que el personaje tenga el rifle
        if not player.Character or not player.Character:FindFirstChild("RifleGun") then
            if debug then
                print("RifleGun no encontrado en el personaje")
            end
            return false
        end
        
        -- Crear un ID único para el objetivo basado en su posición
        local targetId = "OPEN_ME_" .. tostring(math.floor(target.part.Position.X)) .. "_" .. 
                        tostring(math.floor(target.part.Position.Y)) .. "_" .. 
                        tostring(math.floor(target.part.Position.Z))
        
        -- Hacer que el personaje mire hacia el objetivo
        pcall(function()
            local targetPosition = target.part.Position
            local characterPosition = player.Character.HumanoidRootPart.Position
            local lookVector = (targetPosition - characterPosition).Unit
            local rightVector = Vector3.new(0, 1, 0):Cross(lookVector).Unit
            local upVector = lookVector:Cross(rightVector)
            local currentCFrame = player.Character.HumanoidRootPart.CFrame
            local newCFrame = CFrame.new(
                currentCFrame.Position,
                currentCFrame.Position + lookVector
            )
            player.Character.HumanoidRootPart.CFrame = newCFrame
        end)
        
        -- Disparar con manejo de errores
        local shootSuccess = pcall(function()
            -- Disparar
            local args1 = {
                [1] = "fire",
                [2] = {
                    ["Start"] = player.Character.RifleGun.Hole.CFrame,
                    ["Gun"] = "Rifle",
                    ["joe"] = "true",
                    ["Position"] = target.part.Position
                }
            }
            
            -- Usar pcall para evitar errores
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("CIcklcon"):FireServer(unpack(args1))
            end)
            
            -- Generar evento de daño - FIX para el error de FireServer
            local guncastRemote = getNil("guncast", "RemoteEvent")
            if guncastRemote then
                local args2 = {
                    [1] = target.part.Position,
                    [2] = target.part,
                    [3] = 0.1
                }
                
                pcall(function()
                    guncastRemote:FireServer(unpack(args2))
                end)
            else
                if debug then
                    print("RemoteEvent 'guncast' no encontrado")
                end
            end
        end)
        
        -- Verificar si el objetivo sigue vivo después de disparar
        local targetStillAlive = false
        pcall(function()
            if target.npc and target.npc:FindFirstChild("Humanoid") and target.npc.Humanoid.Health > 0 then
                targetStillAlive = true
            end
        end)
        
        -- Si el objetivo sigue vivo, marcarlo como fallido
        if targetStillAlive then
            -- Inicializar la tabla failedTargets si no existe
            if failedTargets == nil then
                failedTargets = {}
            end
            
            -- Actualizar o crear el registro de intentos
            if not failedTargets[targetId] then
                failedTargets[targetId] = {
                    time = tick(),
                    attempts = 1,
                    raycastOnly = false,
                    position = target.part.Position
                }
                if debug then
                    print("Nuevo objetivo fallido registrado: " .. targetId)
                end
            else
                -- CORREGIDO: Incrementar explícitamente el contador de intentos
                failedTargets[targetId].time = tick()
                failedTargets[targetId].attempts = (failedTargets[targetId].attempts or 0) + 1
                
                -- Marcar como raycastOnly después de 3 intentos
                if failedTargets[targetId].attempts >= 3 and not failedTargets[targetId].raycastOnly then
                    -- Marcar explícitamente como raycastOnly
                    failedTargets[targetId].raycastOnly = true
                    
                    if debug then
                        print("⚠️ Objetivo marcado como raycastOnly después de " .. failedTargets[targetId].attempts .. " disparos: " .. targetId)
                        Window:Notify({
                            Title = "Objetivo problemático",
                            Description = "Marcando enemigo como raycastOnly después de múltiples intentos",
                            Lifetime = 3
                        })
                    end
                    
                    -- Cambiar de posición para intentar desde otro ángulo
                    if wave3State == "posicion_base" then
                        if debug then print("Cambiando a posición intermedia1 para objetivos raycast") end
                        wave3State = "posicion_intermedia1"
                        pcall(function() tween(posicionIntermedia1) end)
                    elseif wave3State == "posicion_primaria" then
                        if debug then print("Cambiando a posición intermedia2 para objetivos raycast") end
                        wave3State = "regreso_intermedia2"
                        pcall(function() tween(posicionIntermedia2) end)
                    end
                end
            end
            
            if debug then
                print("Objetivo no eliminado, marcado como fallido: " .. targetId .. " (Intento " .. tostring(failedTargets[targetId].attempts) .. ")")
            end
        else
            -- Si el objetivo fue eliminado, eliminarlo de la lista de fallidos
            if failedTargets[targetId] then
                failedTargets[targetId] = nil
                if debug then
                    print("✅ Objetivo eliminado correctamente, removido de la lista de fallidos: " .. targetId)
                end
            end
        end
        
        if not shootSuccess and debug then
            print("Error al disparar")
        end
        
        return shootSuccess
    end
    
    -- Bucle principal
    local function mainLoop()
        -- Desconectar cualquier conexión anterior
        if heartbeatConnection then
            pcall(function()
                heartbeatConnection:Disconnect()
            end)
            heartbeatConnection = nil
        end
        
        if config.visualizeTarget then
            pcall(function()
                createTargetMarker()
            end)
        end
        
        -- Crear nueva conexión
        local success, connection = pcall(function()
            return runService.Heartbeat:Connect(function()
                -- Verificar si el farming está desactivado
                if not farm or not config.enabled then
                    if heartbeatConnection then
                        pcall(function()
                            heartbeatConnection:Disconnect()
                        end)
                        heartbeatConnection = nil
                    end
                    return
                end
                
                -- Envolver todo en pcall para capturar errores sin romper el script
                local success, errorMsg = pcall(function()
                    -- Verificar si tenemos el rifle equipado
                    local character = player.Character
                    if not character or not character:FindFirstChild("RifleGun") then
                        return
                    end
                    
                    -- Encontrar objetivo
                    currentTarget = findOPENME()
                    
                    -- Actualizar marcador visual
                    if targetMarker and currentTarget then
                        pcall(function()
                            targetMarker.Position = currentTarget.part.Position
                            targetMarker.Transparency = 0.5
                        end)
                    elseif targetMarker then
                        pcall(function()
                            targetMarker.Transparency = 1
                        end)
                    end
                    
                    -- Disparar si tenemos objetivo
                    if currentTarget then
                        local success = shootTarget(currentTarget)
                        if not success and config.autoReload then
                            reloadRifle()
                        end
                    end
                end)
                
                -- Manejar errores dentro del Heartbeat
                if not success and debug then
                    print("Error en mainLoop: " .. tostring(errorMsg))
                    Window:Notify({
                        Title = "ERRRRROR",
                        Description = "OwO: " .. tostring(errorMsg),
                        Lifetime = 3
                    })
                end
            end)
        end)
        
        if success and connection then
            heartbeatConnection = connection
            if debug then
                print("Conexión Heartbeat establecida correctamente")
            end
        else
            if debug then
                print("Error al crear la conexión Heartbeat: " .. tostring(connection))
                if debug then
                    Window:Notify({
                    Title = "Error en Wave 3",
                    Description = "No se pudo establecer la conexión. El script continuará pero podría haber problemas.",
                    Lifetime = 5
                })
            end
            end
        end
    end
    
    
    
    
    
    
    
    -- Función para el control de Wave 3
    -- Función para el control de Wave 3
    doWave3 = function()
        waveStartTime = tick()
        if not farm then
            -- Desconectar Heartbeat al salir
            if heartbeatConnection then
                pcall(function()
                    heartbeatConnection:Disconnect()
                end)
                heartbeatConnection = nil
            end
            return false 
        end
        
        if debug then
            print("Ejecutando lógica de Wave 3")
        end
    
        -- Variables para las posiciones estratégicas
        local posicionBase = wavePositions[3][7] -- Posición base para disparar
        
        -- Actualización de las coordenadas según el nuevo recorrido
        local posicionIntermedia1 = Vector3.new(-2859, 66, -23)
        local posicionIntermedia2 = Vector3.new(-2727, 38, -67)
        local posicionPrimaria = Vector3.new(-2680, 80, -126)
        
        -- Estado de la secuencia
        if wave3State == nil then
            wave3State = "inicio"
        end
        
        -- CORRECCIÓN: Asegurarse de que lastEnemyDetectedTime esté inicializado correctamente
        if lastEnemyDetectedTime == nil then
            lastEnemyDetectedTime = tick()
            if debug then
                print("Inicializando lastEnemyDetectedTime: " .. lastEnemyDetectedTime)
            end
        end
        
        -- Usar pcall para manejar errores en la configuración inicial
        local success, errorMsg = pcall(function()
            if not wave3 then
                -- Equipar rifle
                local equipSuccess = equipWeapon("Rifle")
                if not equipSuccess and debug then
                    print("No se pudo equipar el rifle, continuando de todos modos")
                end
                
                -- Posicionar inicialmente en la posición base 3,4
                pcall(function() 
                    if debug then print("Posicionando en la posición base 3,4") end
                    gotoWavePosition(3, 1)
                    gotoWavePosition(3, 2)
                    gotoWavePosition(3, 3)
                    gotoWavePosition(3, 4) 
                    gotoWavePosition(3, 5)
                    gotoWavePosition(3, 6)
                    gotoWavePosition(3, 7) 
                end)
                
                wave3 = true
                    wave3State = "posicion_base"
                    lastEnemyDetectedTime = tick() -- Reiniciar el contador al iniciar Wave 3
                    if debug then
                        print("Wave 3 iniciada, lastEnemyDetectedTime: " .. lastEnemyDetectedTime)
                    end
                end
    
            if wave3 then
                -- Función para detectar enemigos sin raycast (visibles directamente)
                local function hayEnemigosSinRaycast()
                    local resultado = false
                    
                    pcall(function()
                        if workspace and workspace:FindFirstChild("NPCs") then
                            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                    local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                                    if targetPart then
                                        -- Comprobar si hay obstáculos mediante raycast
                                        local ray = Ray.new(player.Character.HumanoidRootPart.Position, targetPart.Position - player.Character.HumanoidRootPart.Position)
                                        local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                        
                                        -- Si NO hay obstáculos (hit es nil), entonces hay enemigos sin raycast
                                        if hit == nil then
                                            resultado = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    
                    return resultado
                end
                
                -- Función para detectar enemigos con raycast (detrás de obstáculos)
                local function hayEnemigosConRaycast()
                    local resultado = false
                    
                    pcall(function()
                        if workspace and workspace:FindFirstChild("NPCs") then
                            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                    local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                                    if targetPart then
                                        -- Comprobar si hay obstáculos mediante raycast
                                        local ray = Ray.new(player.Character.HumanoidRootPart.Position, targetPart.Position - player.Character.HumanoidRootPart.Position)
                                        local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                        
                                        -- Si hay obstáculos (hit no es nil), entonces hay enemigos con raycast
                                        if hit ~= nil then
                                            resultado = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    
                    return resultado
                end
                
                -- Verificar si hay enemigos visibles (cualquier tipo)
                local hayEnemigos = false
                    pcall(function()
                        if workspace and workspace:FindFirstChild("NPCs") then
                            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                    hayEnemigos = true
                                    -- CORRECCIÓN: Actualizar tiempo de último enemigo detectado
                                    lastEnemyDetectedTime = tick()
                                    if debug then
                                        print("OPEN ME detectado, actualizando lastEnemyDetectedTime: " .. lastEnemyDetectedTime)
                                    end
                                    break
                                end
                            end
                        end
                    end)
                
                -- CORRECCIÓN: Verificar si han pasado 10 segundos sin enemigos para cambiar a Wave 4
                local tiempoSinEnemigos = tick() - lastEnemyDetectedTime
                
                -- Mostrar tiempo sin enemigos en debug
                if debug and not hayEnemigos then
                    print("Tiempo sin enemigos OPEN ME: " .. math.floor(tiempoSinEnemigos) .. "/10 segundos")
                end
    
                -- CORRECCIÓN: Solo verificar el cambio a Wave 4 si no hay enemigos
                if not hayEnemigos then
                    -- Si han pasado 10 segundos sin enemigos, cambiar a Wave 4
                    if tiempoSinEnemigos >= 10 then
                        -- Verificar una vez más que realmente no hay enemigos (doble verificación)
                        local verificacionFinal = false
                        pcall(function()
                            if workspace and workspace:FindFirstChild("NPCs") then
                                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                        verificacionFinal = true
                                        break
                                    end
                                end
                            end
                        end)
                        
                        if not verificacionFinal then
                            if debug then 
                                print("No se han detectado OPEN ME durante 10 segundos continuos. Cambiando a Wave 4...")
                            end
                            
                            if debug then
                                Window:Notify({
                                Title = "Cambio de Wave",
                                Description = "No se detectaron OPEN ME por 10 segundos. Pasando a Wave 4",
                                Lifetime = 5
                            })
                        end
                            
                            -- Desactivar el heartbeat para que no siga disparando durante la transición
                            if heartbeatConnection then
                                pcall(function()
                                    heartbeatConnection:Disconnect()
                                end)
                                heartbeatConnection = nil
                            end
                            
                            -- Cambiar a Wave 4
                            wave = 4
                            if waveParagraph then
                                waveParagraph:UpdateBody("Wave 4!")
                            end
                            
                            -- Secuencia de movimiento a Wave 4
                            wait(10)
                            pcall(function() gotoWavePosition(4, 1) end)
                            pcall(function() gotoWavePosition(4, 2) end)
                            pcall(function() gotoWavePosition(4, 3) end)
                            wait(1)
                            
                            -- Reiniciar variables de Wave 3
                            wave3 = false
                            wave3State = nil
                            lastEnemyDetectedTime = nil
                            wave3EnemyStabilized = false
                            enemigosPreviosCount = 0
                            
                            return true -- Indicar cambio de wave
                        else
                            -- Si la verificación final encontró enemigos, reiniciar el contador
                            if debug then
                                print("Verificación final encontró enemigos. Reiniciando contador.")
                            end
                            lastEnemyDetectedTime = tick()
                        end
                    end
                else
                    -- CORRECCIÓN: Si hay enemigos, actualizar el tiempo de último enemigo detectado
                    lastEnemyDetectedTime = tick()
                    if debug then
                        print("Hay enemigos OPEN ME, reiniciando contador")
                    end
                end
                
                -- NUEVA LÓGICA: Manejar estados según los tipos de enemigos
                
                -- Si estamos en la posición base
                if wave3State == "posicion_base" or wave3State == "inicio" then
                    -- Verificar si estamos en la posición base, si no, volver a ella
                    local currentPosition = player.Character.HumanoidRootPart.Position
                    local baseDistance = (posicionBase - currentPosition).Magnitude
                    if baseDistance > 10 then
                        if debug then print("Volviendo a posición base 3,7 para disparar") end
                        pcall(function() tween(posicionBase) end)
                    else
    
                        -- Ya estamos en la posición base, verificar tipos de enemigos
                        
                        -- NUEVO: Verificar si siguen apareciendo enemigos
                        local enemigosPrevios = 0
                        local enemigosActuales = 0
                        
                        -- Contar enemigos actuales
                        pcall(function()
                            if workspace and workspace:FindFirstChild("NPCs") then
                                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                        enemigosActuales = enemigosActuales + 1
                                    end
                                end
                            end
                        end)
    
                        if not wave3EnemyStabilized then
                            -- Initialize enemigosPreviosCount if it's nil
                            if enemigosPreviosCount == nil then
                                enemigosPreviosCount = 0
                            end
                            
                            if enemigosActuales > enemigosPreviosCount then
                                -- Siguen apareciendo enemigos, actualizar contador y esperar
                                enemigosPreviosCount = enemigosActuales
                                if debug then print("Esperando a que dejen de aparecer OPEN ME. Actuales: " .. enemigosActuales) end
                                config.enabled = false -- Desactivar disparos mientras esperamos
                            else
                                -- El número de enemigos se ha estabilizado o reducido
                                if debug then print("OPEN ME estabilizados. Comenzando a disparar.") end
                                wave3EnemyStabilized = true
                                config.enabled = true -- Activar disparos
                            end
                        end
                        -- Ya estamos en la posición base, verificar tipos de enemigos
                        if wave3EnemyStabilized and hayEnemigosSinRaycast() then
                            -- Si hay enemigos sin raycast y ya se estabilizaron, quedarse en posición base y disparar
                            if debug then print("Disparando desde posición base a enemigos sin raycast") end
                        elseif wave3EnemyStabilized and hayEnemigosConRaycast() then
                            -- SOLO si no hay enemigos sin raycast pero SÍ hay con raycast, ir a posición primaria
                            -- con pasos intermedios para evitar detección de anti-cheat
                            if debug then print("Solo quedan enemigos con raycast. Cambiando a posición primaria con pasos intermedios") end
                            wave3State = "posicion_intermedia1"
                            pcall(function() tween(posicionIntermedia1) end)
                        end
                    end
                -- Si estamos en la primera posición intermedia
                elseif wave3State == "posicion_intermedia1" then
                    if debug then print("Moviendo a posición intermedia 2") end
                    wave3State = "posicion_intermedia2"
                    pcall(function() tween(posicionIntermedia2) end)
                -- Si estamos en la segunda posición intermedia
                elseif wave3State == "posicion_intermedia2" then
                    if debug then print("Moviendo a posición primaria final") end
                    wave3State = "posicion_primaria"
                    pcall(function() tween(posicionPrimaria) end)
                -- Si estamos en la posición primaria
            elseif wave3State == "posicion_primaria" then
                -- Si hay enemigos sin raycast, volver a posición base usando el mismo recorrido inverso
                if hayEnemigosSinRaycast() then
                    if debug then print("Hay enemigos sin raycast, iniciando regreso a posición base") end
                    wave3State = "regreso_intermedia2"
                    pcall(function() 
                        local tweenSuccess = tween(posicionIntermedia2)
                        if not tweenSuccess and debug then
                            print("Tween a posicionIntermedia2 falló, intentando teleport directo")
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionIntermedia2)
                        end
                    end)
                -- Si no hay enemigos, volver a posición base
                elseif not hayEnemigos then
                    if debug then print("No hay más enemigos, iniciando regreso a posición base") end
                    wave3State = "regreso_intermedia2"
                    pcall(function() 
                        local tweenSuccess = tween(posicionIntermedia2)
                        if not tweenSuccess and debug then
                            print("Tween a posicionIntermedia2 falló, intentando teleport directo")
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionIntermedia2)
                        end
                    end)
                else
                    -- Disparar desde posición actual
                    if debug then print("Disparando desde posición primaria") end
                end
                -- NUEVO: Estados para el recorrido inverso
            elseif wave3State == "regreso_intermedia2" then
                if debug then print("Regresando a posición intermedia 1") end
                wave3State = "regreso_intermedia1"
                pcall(function() 
                    local tweenSuccess = tween(posicionIntermedia1)
                    if not tweenSuccess and debug then
                        print("Tween a posicionIntermedia1 falló, intentando teleport directo")
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionIntermedia1)
                    end
                    -- Esperar a que el tween termine
                    wait(1)
                end)
            elseif wave3State == "regreso_intermedia1" then
                if debug then print("Regresando a posición base") end
                wave3State = "posicion_base"
                pcall(function() 
                    local tweenSuccess = tween(posicionBase)
                    if not tweenSuccess and debug then
                        print("Tween a posicionBase falló, intentando teleport directo")
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionBase)
                    end
                    -- Esperar a que el tween termine
                    wait(1)
                end)
                end
                
                -- Activar el farming para disparar
                if farm then
                    config.enabled = true
                    if not heartbeatConnection then
                        mainLoop()
                    end
                else
                    config.enabled = false
                    -- Desconectar Heartbeat cuando farm es falso
                    if heartbeatConnection then
                        pcall(function()
                            heartbeatConnection:Disconnect()
                        end)
                        heartbeatConnection = nil
                    end
                end
            end
        end)
        
        -- Manejar errores en la configuración de Wave 3
        if not success then
            if debug then
                print("Error en configuración de Wave 3: " .. tostring(errorMsg))
                if debug then               
                    Window:Notify({
                    Title = "Error recuperable",
                    Description = "Error en Wave 3: " .. tostring(errorMsg) .. ". El script continuará.",
                    Lifetime = 3
                })
            end
            end
            wait(2)
        end
        
        wait(1)
        return false -- Seguir en Wave 3
    end
    
    
    --[[
    
    
    wave 4
    
    
    ]]--
    
    -- Función para el control de Wave 4
    -- Modify the doWave4 function
    doWave4 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        if debug then
            print("Ejecutando lógica de Wave 4")
        end
        
        -- Verificar si estamos en la posición correcta para Wave 4
        local currentPosition = player.Character.HumanoidRootPart.Position
        local targetPosition = wavePositions[4][3] -- Posición final de Wave 4
        local distanceToTarget = (currentPosition - targetPosition).Magnitude
        
        -- Si no estamos en la posición correcta, ir a ella primero
        if distanceToTarget > 10 then
            if debug then print("Yendo a la posición final de Wave 4...") end
            gotoWavePosition(4, 3)
            wait(1)
        end
        
        -- Buscar regalos cercanos
        local allGifts = getAllGifts()
        if debug then print("Wave 4: Encontrados " .. #allGifts .. " regalos en total") end
        
        -- Si no hay regalos, esperar un poco y verificar si debemos pasar a Wave 5
        if #allGifts == 0 then
            wave = 5
            if debug then print("No se encontraron regalos en Wave 4, esperando...") end
            wait(1)
            
            -- Verificar si debemos pasar a Wave 5 (puedes ajustar esta lógica)
            local shouldMoveToWave5 = false
            
            -- Ejemplo: verificar si estamos en una posición específica que indica el final de Wave 4
            local finalPosition = Vector3.new(-3158, 120, -16) -- Ajusta esta posición
            local distanceToFinal = (currentPosition - finalPosition).Magnitude
            
            if distanceToFinal < 10 then
                -- Si estamos cerca de la posición final y no hay regalos, considerar pasar a Wave 5
                shouldMoveToWave5 = true
            end
            
            if shouldMoveToWave5 then
                if debug then print("Pasando a Wave 5...") end
                wave = 5
                if waveParagraph then
                    waveParagraph:UpdateBody("Wave 5!")
                end
                
                -- Ir a la primera posición de Wave 5
                gotoWavePosition(5, 1)
                wait(1)
                
                return true -- Indicar cambio de wave
            end
            
            return false -- Seguir en Wave 4
        end
        
        -- Procesar los regalos encontrados
        local closestGift = nil
        local minDistance = math.huge
        
        for _, gift in ipairs(allGifts) do
            -- Obtener la posición del regalo
            local giftPosition = getObjectPosition(gift)
            
            if giftPosition then
                local distance = (currentPosition - giftPosition).Magnitude
                
                -- Verificar si este regalo ya fue procesado
                local giftId = tostring(giftPosition)
                if not processedGifts[giftId] and distance < minDistance then
                    minDistance = distance
                    closestGift = {
                        objeto = gift,
                        posicion = giftPosition
                    }
                end
            end
        end
        
        -- Si encontramos un regalo no procesado, ir a recogerlo
        if closestGift then
            if debug then
                print("Wave 4: Recogiendo regalo a " .. math.floor(minDistance) .. " distancia")
            end
            
            -- Marcar este regalo como procesado
            local giftId = tostring(closestGift.posicion)
            processedGifts[giftId] = true
            
            -- Moverse al regalo e interactuar
            local moveSuccess = tweenwave4(closestGift.posicion)
            
            -- Si el tween falló, intentar teletransporte directo
            if not moveSuccess then
                if debug then print("Tween falló, usando teletransporte directo") end
                pcall(function()
                    hRP.CFrame = CFrame.new(closestGift.posicion)
                    wait(0.5)
                end)
            end
            
            -- Esperar un momento para que se recoja el regalo
            wait(1)
            
            -- Notificar al usuario
            if debug then
                Window:Notify({
                Title = "Regalo recogido",
                Description = "Regalo de Wave 4 recogido con éxito",
                Lifetime = 2
            })
        end
            
            -- Volver a la posición principal de Wave 4
            gotoWavePosition(4, 3)
            wait(0.5)
        else
            -- Si todos los regalos visibles ya fueron procesados, limpiar la lista
            -- para permitir que se procesen nuevamente en caso de que aparezcan nuevos
            if #allGifts > 0 then
                processedGifts = {}
                if debug then
                    print("Reiniciando lista de regalos procesados en Wave 4")
                end
            end
            
            -- Esperar un momento antes de buscar más regalos
            wait(0.5)
        end
        
        return false -- Seguir en Wave 4
    end
    
    --[[
    
    wave 5
    
    
    ]]--
    
    
    
    
    
    -- Función para el control de Wave 5
    -- Función para el control de Wave 5
    wave5Started = false -- Definir fuera de la función
    
    
    doWave5 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        if debug then
            print("Ejecutando lógica de Wave 5")
        end
    
        -- Si wave5 ya se ejecutó, no repetir
        if not wave5Started then
            equipWeapon("Mega-Pow")
            equipItem("Mega-Pow")
            gotoWavePosition(5, 1)
            gotoWavePosition(5, 2)
            gotoWavePosition(5, 3)
            gotoWavePosition(5, 4)
            setupBodyVelocity()
            wave5Started = true -- Ahora ya no se ejecutará más de una vez
        end
    
        -- Buscar el NPC "A present...?" o "Supreme Giftbox, Rocky" en workspace.NPCs
        local targetNPC = nil
    
        -- Primero intentamos encontrar "A present...?"
        for _, npc in pairs(workspace.NPCs:GetChildren()) do
            if npc.Name == "A present...?" then
                targetNPC = npc
                if debug then 
                    print("NPC 'A present...?' encontrado")
                end
                break
            end
        end
    
        -- Si no encontramos "A present...?", buscamos "Supreme Giftbox, Rocky"
        if not targetNPC then
            if workspace.NPCs:FindFirstChild("Supreme Giftbox, Rocky") then
                targetNPC = workspace.NPCs["Supreme Giftbox, Rocky"]
                if debug then
                    print("NPC 'Supreme Giftbox, Rocky' encontrado con índice directo")
                end
            else
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc.Name == "Supreme Giftbox, Rocky" then
                        targetNPC = npc
                        if debug then
                            print("NPC 'Supreme Giftbox, Rocky' encontrado con búsqueda")
                        end
                        break
                    end
                end
            end
        end
    
        -- NUEVO: Si no encontramos ningún NPC, buscar YearGiftAniBoss24 en workspace.Effects.PresentModels
        local bossGiftsFound = false
        if not targetNPC then
            local bossGifts = {}
            
            -- Buscar en workspace.Effects.PresentModels
            pcall(function()
                if workspace.Effects and workspace.Effects.PresentModels then
                    for _, gift in pairs(workspace.Effects.PresentModels:GetChildren()) do
                        if gift.Name == "YearGiftAniBoss24" then
                            table.insert(bossGifts, gift)
                            if debug then
                                print("YearGiftAniBoss24 encontrado en Effects.PresentModels")
                            end
                        end
                    end
                end
            end)
            
            -- Si encontramos regalos especiales, ir a ellos
            if #bossGifts > 0 then
                bossGiftsFound = true
                for _, gift in ipairs(bossGifts) do
                    local giftPos = getObjectPosition(gift)
                    if giftPos then
                        if debug then
                            print("Yendo a YearGiftAniBoss24 en posición: " .. tostring(giftPos))
                        end
                        
                        -- Tween al regalo especial - acercarse lo suficiente para la interacción
                        tween(giftPos)
                        wait(1)
                        
                        -- MEJORADO: Secuencia de interacción con el ProximityPrompt
                        pcall(function()
                            -- Primero presionar E para activar la interacción
                            vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                            wait(0.2)
                            vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                            
                            wait(0.5) -- Esperar un momento
                            
                            -- Buscar el ProximityPrompt en la estructura del objeto
                            local proximityPrompt = nil
                            
                            -- Buscar en la estructura específica que vemos en la imagen
                            if gift:FindFirstChild("BottomMiddle") and 
                               gift.BottomMiddle:FindFirstChild("ProximityPrompt") then
                                proximityPrompt = gift.BottomMiddle.ProximityPrompt
                                if debug then
                                    print("ProximityPrompt encontrado en BottomMiddle")
                                end
                            else
                                -- Búsqueda recursiva como respaldo
                                for _, descendant in pairs(gift:GetDescendants()) do
                                    if descendant:IsA("ProximityPrompt") then
                                        proximityPrompt = descendant
                                        if debug then
                                            print("ProximityPrompt encontrado en búsqueda recursiva")
                                        end
                                        break
                                    end
                                end
                            end
                            
                            -- Si encontramos el ProximityPrompt, activarlo
                            if proximityPrompt then
                                -- Intentar fireproximityprompt varias veces para asegurar la interacción
                                for i = 1, 3 do
                                    if debug then
                                        print("Intento " .. i .. " de fireproximityprompt")
                                    end
                                    
                                    fireproximityprompt(proximityPrompt)
                                    wait(0.5)
                                end
                                
                                -- Presionar E nuevamente como respaldo
                                vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                wait(0.2)
                                vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                
                                if debug then
                                    print("Secuencia de interacción completa con YearGiftAniBoss24")
                                end
                            else
                                if debug then
                                    print("No se encontró ProximityPrompt, usando solo keypress")
                                end
                                
                                -- Si no encontramos el ProximityPrompt, intentar con más keypresses
                                for i = 1, 3 do
                                    vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                    wait(0.2)
                                    vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                    wait(0.3)
                                end
                            end
                        end)
                        
                        -- Esperar un momento para que se complete la interacción
                        wait(2)
                    end
                end
                
                wait(1)
                return false -- Continuar en Wave 5
            end
        end
    
        -- NUEVO: Si no hay NPCs ni regalos, tween a la posición especificada
        if not targetNPC and not bossGiftsFound then
            if debug then
                print("No se encontraron NPCs ni YearGiftAniBoss24, yendo a posición alternativa")
            end
            
            -- Posición alternativa cuando no hay objetivos
            local alternativePosition = Vector3.new(-4345, 43, -5)
            
            -- Notificar al usuario
            if debug then
                Window:Notify({
                Title = "Wave 5 - Sin objetivos",
                Description = "No se encontraron objetivos. Yendo a posición alternativa.",
                Lifetime = 3
            })
        end
            
            -- Ir a la posición alternativa
            tween(alternativePosition)
            wait(2)
            
            return false -- Continuar en Wave 5
        end
    
        -- Sólo continuar si encontramos el NPC objetivo
        if targetNPC then
            if targetNPC:FindFirstChild("HumanoidRootPart") then
                local targetPosition = targetNPC.HumanoidRootPart.Position
                local playerPosition = player.Character.HumanoidRootPart.Position
                
                -- NUEVO: Verificar si el NPC está saltando o ha aterrizado
                local isJumping = targetPosition.Y > 100 -- Si Y > 100, está saltando
                local isOnGround = targetPosition.Y >= 60 and targetPosition.Y <= 70 -- Si Y está entre 60-70, está en el suelo
                local isBelowPlayer = targetPosition.Y < playerPosition.Y -- Si está por debajo del jugador
                
                if debug then
                    print("Posición Y del NPC: " .. targetPosition.Y)
                    print("¿Está saltando? " .. tostring(isJumping))
                    print("¿Está en el suelo? " .. tostring(isOnGround))
                    print("¿Está debajo del jugador? " .. tostring(isBelowPlayer))
                end
                
                -- NUEVO: Solo disparar si el NPC está en el suelo (después de saltar) y por debajo del jugador
                if (isOnGround or not isJumping) and isBelowPlayer then
                    if debug then
                        print("Condiciones cumplidas para disparar: NPC en suelo o no saltando, y debajo del jugador")
                    end
                    
                    local args = {
                        [1] = true,
                        [2] = targetPosition
                    }
                    
                    local character = game:GetService("Players").LocalPlayer.Character
                    if character and character:FindFirstChild("Mega-Pow") then
                        character:FindFirstChild("Mega-Pow").MinigunHandleServer.input:InvokeServer(unpack(args))
                        if debug then
                            
                        print("Disparando a '" .. targetNPC.Name .. "' en la posición: " .. tostring(targetPosition))
                        end
                    else
                        warn("No megapow 🤔")
                        equipWeapon("Mega-Pow")
                    end
                else
                    if debug then
                        print("No disparando: NPC está saltando o no está debajo del jugador")
                    end
                end
            else
                warn("El NPC objetivo no tiene HumanoidRootPart.")
            end
        else
            warn("No se encontró ningún NPC objetivo ni YearGiftAniBoss24.")
        end
    
        wait(1)
        return false -- Seguir en Wave 5
    end
    
    
    -- Tabla de funciones de wave para acceso fácil
    local waveFunctions = {
        [1] = doWave1,
        [2] = doWave2,
        [3] = doWave3,
        [4] = doWave4,
        [5] = doWave5
    }
    
    -- Función para verificar si todas las funciones de wave están definidas
    local function verificarWaves()
        print("wowGyat: ")
        print("Wave 1: " .. (type(doWave1) == "function" and "OK" or "FALTA"))
        print("Wave 2: " .. (type(doWave2) == "function" and "OK" or "FALTA"))
        print("Wave 3: " .. (type(doWave3) == "function" and "OK" or "FALTA"))
        print("Wave 4: " .. (type(doWave4) == "function" and "OK" or "FALTA"))
        print("Wave 5: " .. (type(doWave5) == "function" and "OK" or "FALTA"))
    end
    
    -- Verificar funciones de wave
    verificarWaves()
    
    -- Función principal para farming que maneja todas las waves
    local function StartFarm()
        if not farm then 
            -- Desconectar Heartbeat al detener el farming
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
            return 
        end
    
    
        spawn(function()
            if debug then
                print("Iniciando farm en Wave " .. wave)
            end
            
            while farm do
                -- Usar el sistema de funciones con manejo de errores
                local currentWaveFunction = waveFunctions[wave]
                if not currentWaveFunction then
                    if debug then
                        print("Error: Función para Wave " .. wave .. " no encontrada")
                    end
                    -- Cambiar a Wave 1 para recuperar el sistema
                    wave = 1
                    if waveParagraph then
                        waveParagraph:UpdateBody("Wave 1!")
                    end
                    wait(2)
                    -- 'continue' no existe en Lua, usamos un else para el resto del código
                else
                    -- Usar pcall para evitar que un error detenga todo el proceso
                    local success, waveChanged = pcall(function()
                        return currentWaveFunction()
                    end)
                    
                    if not success then
                        if debug then
                            print("Error en Wave " .. wave .. ": " .. tostring(waveChanged))
                            if debug then
                                Window:Notify({
                                Title = "Error recuperable",
                                Description = "Error en Wave " .. wave .. ". Reintentando...",
                                Lifetime = 3
                            })
                        end
                        end
                        wait(2)
                    end
                    
                    if not farm then 
                        -- Desconectar Heartbeat al detener el farming
                        if heartbeatConnection then
                            heartbeatConnection:Disconnect()
                            heartbeatConnection = nil
                        end
                        break 
                    end
                end
                wait(0.1)
            end
            
            if debug then
                print("Farm detenido")
            end
        end)
    end

--[[












anni logica arriba


















]]--




function createTween(instance, tweenInfo, properties, isMissionTween)
    local tween = originalTweenCreate(TweenService, instance, tweenInfo, properties)
    
    if isMissionTween then
        -- Si es tween de misión, agregarlo a la lista específica
        table.insert(questTweens, tween)
    else
        -- Si es tween regular, agregarlo a la lista normal
        table.insert(activeTweens, tween)
    end
    
    tween.Completed:Connect(function(status)
        -- Eliminar de la lista regular
        for i, t in ipairs(activeTweens) do
            if t == tween then
                table.remove(activeTweens, i)
                break
            end
        end
        
        -- Eliminar de la lista de tweens de misiones
        for i, t in ipairs(questTweens) do
            if t == tween then
                table.remove(questTweens, i)
                break
            end
        end
    end)
    
    return tween
end

-- Función actualizada para cancelar tweens con opción de preservar tweens de misión
function cancelAllActiveTweens(preserveMissionTweens)
    -- Si preserveMissionTweens es true, solo cancelamos tweens regulares
    if preserveMissionTweens then
        for _, tween in ipairs(activeTweens) do
            pcall(function() tween:Cancel() end)
        end
        activeTweens = {}
    else
        -- Cancelar todos los tweens (regulares y de misión)
        for _, tween in ipairs(activeTweens) do
            pcall(function() tween:Cancel() end)
        end
        activeTweens = {}
        
        for _, tween in ipairs(questTweens) do
            pcall(function() tween:Cancel() end)
        end
        questTweens = {}
    end
end

-- Variables principales
local player = game:GetService("Players").LocalPlayer
local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

task.spawn(function()

    Window:Notify({
        Title = "Anti-AFK",
        Description = "antiafk enabled",
        Lifetime = 3
    })
    

    while true do
        pcall(function() 
            
            -- Use VirtualInputManager instead of keypress/keyrelease
            -- Convert hex keys to KeyCode enum values
            local keys = {Enum.KeyCode.Z, Enum.KeyCode.X, Enum.KeyCode.V, Enum.KeyCode.L} -- Equivalent to 0x5A, 0x58, 0x56, 0x4C
            local randomKey = keys[math.random(1, #keys)]
            
            -- Send key down event
            vim:SendKeyEvent(true, randomKey, false, game)
            task.wait(0.05)
            -- Send key up event
            vim:SendKeyEvent(false, randomKey, false, game)
            
        end)
        
        if math.random(1, 2) == 1 then
            Window:Notify({
                Title = "Anti-AFK",
                Description = "OUSI.HUB ON TOP",
                Lifetime = 2
            })
        end
        
        for i = 1, 6 do
            task.wait(10)
        end
    end
end)

local function calcularDuracionTween(origen, destino, velocidad)
    if typeof(origen) == "Vector3" and typeof(destino) == "Vector3" then
        local distancia = (Vector3.new(destino.X, 0, destino.Z) - Vector3.new(origen.X, 0, origen.Z)).Magnitude
        return tonumber(distancia / velocidad) -- Aseguramos que retorne un número
    end
    return 1 -- valor por defecto si hay error (cambiado de 0 a 1 para evitar división por cero)
end
-- Variable global para control
_G.KaitunActive = false
-- Eliminamos la variable QuestActive ya que ahora será parte integral del auto farm

-- Variable para controlar si ya está iniciado el auto shooting
local autoShootingStarted = false
-- Eliminamos questLoopStarted ya que ahora se manejará diferente

local function startAutoShooting()
    -- Si ya está iniciado, no hacer nada
    if autoShootingStarted then return end
    autoShootingStarted = true

    local runService = game:GetService("RunService")
    local lastShot = 0
    local isReloading = false
    local targetMarker = nil
    
    -- Variable para controlar ciclo de quest
    local lastQuestCheck = 0
    local questCheckCooldown = 5 -- Verificar cada 5 segundos
    
    -- Variable para rastrear si el ciclo de misión está activo
    local isMissionCycleActive = false
    
    -- Función para realizar el ciclo de quest
    local function performQuestCycle()
        -- Variable para seguimiento del BodyVelocity
        local bv = nil
        
        -- Función de limpieza para asegurar que los recursos se eliminen en caso de error
        local function cleanupResources()
            -- Eliminar BodyVelocity si existe
            if bv and bv.Parent then
                bv:Destroy()
                bv = nil
            end
        end
        
        -- Usar pcall para todo el proceso y garantizar limpieza de recursos
        local success, err = pcall(function()
            -- Verificar si el personaje existe
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
                
                return 
            end
            
            -- Verificar si el nivel es mayor o igual a 190
            local playerLevel = 0
            local levelSuccess = pcall(function()
                local hud = player.PlayerGui:FindFirstChild("HUD")
                if not hud then return end
                
                local main = hud:FindFirstChild("Main") 
                if not main then return end
                
                local bars = main:FindFirstChild("Bars")
                if not bars then return end
                
                local experience = bars:FindFirstChild("Experience")
                if not experience then return end
                
                local detail = experience:FindFirstChild("Detail")
                if not detail then return end
                
                local levelLabel = detail:FindFirstChild("Level")
                if not levelLabel then return end
                
                local levelText = levelLabel.Text or ""
                local levelNumber = levelText:match("Level%s*:?%s*(%d+)") or levelText:match("(%d+)")
                if levelNumber then
                    playerLevel = tonumber(levelNumber)
                end
            end)
            
            -- Si no se pudo obtener el nivel o es menor a 190, no continuar con la quest
            if not levelSuccess or playerLevel < 190 then
                Window:Notify({
                    Title = "Ousi.HUB",
                    Description = "no level for quest: " .. playerLevel .. " (req 190+)",
                    Lifetime = 3
                })
                return
            end
            
            -- Posiciones
            local currentPos = player.Character.HumanoidRootPart.Position
            local questPos = Vector3.new(7736, -2176, -17221)
            local farmPos = Vector3.new(7820, -2160, -17145)
            
            
            
            -- Crear BodyVelocity para evitar caídas
            bv = Instance.new("BodyVelocity")
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            bv.Parent = player.Character.HumanoidRootPart
            
            -- Guardar todos los tweens activos para cancelarlos antes de crear uno nuevo
            -- pero preservar los tweens de misión
            cancelAllActiveTweens(true)
            
            -- Sistema mixto: TP para subir, tween para XZ, TP para bajar
            -- 1. TP directo para subir a una altura segura
            local elevationY = 100
            local elevatedPos = Vector3.new(currentPos.X, questPos.Y + elevationY, currentPos.Z)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            player.Character.HumanoidRootPart.CFrame = CFrame.new(elevatedPos)
            task.wait(0.2) -- Pequeña pausa para estabilizar
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end

            -- 2. Tween para movimiento horizontal XZ
            local horizontalPos = Vector3.new(questPos.X, questPos.Y + elevationY, questPos.Z)
            local tweenDuration = calcularDuracionTween(elevatedPos, horizontalPos, 35)
            local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
            local tween = createTween(player.Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(horizontalPos)}, true)
            
            -- Intentar ejecutar el tween
            tween:Play()
            
            -- Esperar a que termine o falle
            local tweenSuccess = pcall(function()
                tween.Completed:Wait()
            end)
            
            if not tweenSuccess then
                cleanupResources()
                
                task.wait(1)
                return performQuestCycle() -- Intentar de nuevo desde el principio
            end
            
            -- Esperar 0.5 segundos antes de hacer TP a Y
            task.wait(0.5)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            -- 3. TP directo para bajar a la posición exacta
            player.Character.HumanoidRootPart.CFrame = CFrame.new(questPos)
            task.wait(0.2) -- Pequeña pausa para estabilizar
            
            -- Verificar la distancia final
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            local distanceToQuest = (player.Character.HumanoidRootPart.Position - questPos).Magnitude
            
            
            -- Esperar un momento para estabilizar antes de tomar la quest
            task.wait(1)
            
            -- Tomar quest una sola vez
            local args = {
                [1] = {
                    [1] = "takequest",
                    [2] = "Help becky"
                }
            }
            
            local questSuccess = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Quest"):InvokeServer(unpack(args))
            end)
            
            if questSuccess then
                
            else
                
            end
            
            -- Regresar a posición de farmeo
            
            
            -- Cancelar tweens activos antes de crear uno nuevo
            -- pero preservar los tweens de misión
            cancelAllActiveTweens(true)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            -- Sistema mixto para el regreso: TP para subir, tween para XZ, TP para bajar
            -- 1. TP directo para subir a una altura segura
            local returnElevatedPos = Vector3.new(questPos.X, questPos.Y + elevationY, questPos.Z)
            player.Character.HumanoidRootPart.CFrame = CFrame.new(returnElevatedPos)
            task.wait(0.2) -- Pequeña pausa para estabilizar
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end

            -- 2. Tween para movimiento horizontal XZ
            local returnHorizontalPos = Vector3.new(farmPos.X, farmPos.Y + elevationY, farmPos.Z)
            local returnTweenDuration = calcularDuracionTween(returnElevatedPos, returnHorizontalPos, 35)
            local returnTweenInfo = TweenInfo.new(returnTweenDuration, Enum.EasingStyle.Linear)
            local returnTween = createTween(player.Character.HumanoidRootPart, returnTweenInfo, {CFrame = CFrame.new(returnHorizontalPos)}, true)
            
            -- Intentar ejecutar el tween de regreso
            returnTween:Play()
            
            -- Esperar a que termine o falle
            local returnTweenSuccess = pcall(function()
                returnTween.Completed:Wait()
            end)
            
            if not returnTweenSuccess then
                cleanupResources()
                
                task.wait(1)
                -- Reintento directo al TP final
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(farmPos)
                end
            end
            
            -- Esperar 0.5 segundos antes de hacer TP a Y
            task.wait(0.5)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            -- 3. TP directo para bajar a la posición exacta
            player.Character.HumanoidRootPart.CFrame = CFrame.new(farmPos)
            task.wait(0.2) -- Pequeña pausa para estabilizar
            
            if returnTweenSuccess then
                local farmPos = Vector3.new(7820, -2160, -17145)
                local distanceToFarm = (player.Character.HumanoidRootPart.Position - farmPos).Magnitude
                
            else
                
            end
            
            return true
        end)
        
        -- Limpieza final garantizada
        cleanupResources()
        
        if not success then
            
            return false
        end
        
        return true
    end
    
    -- Variable para almacenar el último nivel conocido del jugador
    local lastKnownLevel = 0

    -- Función robusta para obtener nivel
    local function getPlayerLevel()
        local playerLevel = 0
        pcall(function()
            local hud = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("HUD")
            if not hud then return end
            
            local main = hud:FindFirstChild("Main") 
            if not main then return end
            
            local bars = main:FindFirstChild("Bars")
            if not bars then return end
            
            local experience = bars:FindFirstChild("Experience")
            if not experience then return end
            
            local detail = experience:FindFirstChild("Detail")
            if not detail then return end
            
            local levelLabel = detail:FindFirstChild("Level")
            if not levelLabel then return end
            
            local levelText = levelLabel.Text or ""
            local levelNumber = levelText:match("Level%s*:?%s*(%d+)") or levelText:match("(%d+)")
            
            if levelNumber then
                playerLevel = tonumber(levelNumber)
            end
        end)
        
        return playerLevel
    end

    -- Agregar este código para verificar el nivel y activar misiones automáticamente
    task.spawn(function()
        while true do
            if _G.KaitunActive then
                -- Verificar nivel cada 5 segundos (más frecuente)
                local currentLevel = getPlayerLevel()
                
                -- Si es la primera vez que verificamos o hubo un cambio de nivel
                if lastKnownLevel ~= currentLevel then
                    -- Notificar cambio de nivel
                    if lastKnownLevel > 0 then
                        Window:Notify({
                            Title = "Level updated",
                            Description = "Current level: " .. currentLevel,
                            Lifetime = 3
                        })
                    end
                    
                    -- Si alcanzamos nivel 190 y no estábamos en él antes
                    if lastKnownLevel < 190 and currentLevel >= 190 then
                        -- Notificar con énfasis
                        Window:Notify({
                            Title = "LEVEL 190 REACHED!!",
                            Description = "Starting quest cycle NOW!",
                            Lifetime = 5
                        })
                        
                        -- En lugar de intentar tomar la misión directamente, iniciar el ciclo completo
                        -- que teleporta al personaje a la posición correcta primero
                        pcall(function()
                            isMissionCycleActive = true
                            performQuestCycle() -- Esta función ya teleporta y luego toma la misión
                            task.wait(1)
                            isMissionCycleActive = false
                        end)
                    end
                    
                    -- Actualizar último nivel conocido
                    lastKnownLevel = currentLevel
                end
                if currentLevel >= 190 then
                    -- Verificar si hay una misión activa
                    local hasActiveQuest = false
                    pcall(function()
                        local questGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Quest")
                        hasActiveQuest = questGui and questGui.Enabled
                    end)
                    
                    -- Si no hay misión activa y no estamos en medio de un ciclo de misión, tomar la misión
                    if not hasActiveQuest and not isMissionCycleActive then
                        Window:Notify({
                            Title = "Quest Check",
                            Description = "Level 190+ but no active quest. Taking quest...",
                            Lifetime = 3
                        })
                        
                        pcall(function()
                            isMissionCycleActive = true
                            performQuestCycle()
                            task.wait(1)
                            isMissionCycleActive = false
                        end)
                    end
                end
            end
            task.wait(5) -- Verificar cada 5 segundos
        end
    end)

    -- Forzar la toma de la misión al inicio del farm
    task.spawn(function()
        -- Esperar un poco para que el personaje se estabilice
        task.wait(2)
        
        
        
        -- Usar pcall para evitar errores de thread
        pcall(function()
            isMissionCycleActive = true
            performQuestCycle()
            task.wait(1)
            isMissionCycleActive = false
        end)
    end)
    
    -- Variables para seguimiento de la última misión
    local lastQuestProgress = -1 -- Inicializado en -1 para detectar el primer cambio

    -- Reemplazar completamente la función checkQuestProgress con esta versión específica
    local function checkQuestProgress()
        local needsNewQuest = false
        local currentProgress = 0
        local totalNeeded = 0
        
        pcall(function()
            -- Usar la ruta exacta proporcionada
            local progressText = game:GetService("Players").LocalPlayer.PlayerGui.Quest.Main.Info.Top.Progress.ContentText
            
            if progressText then
                -- Extraer los números usando pattern matching
                local current, total = string.match(progressText, "(%d+)%s*/%s*(%d+)")
                
                if current and total then
                    currentProgress = tonumber(current)
                    totalNeeded = tonumber(total)
                    
                    -- Verificar si necesitamos una nueva misión basándonos en la lógica descrita:
                    -- Si antes teníamos progreso y ahora volvimos a 0, significa que la misión está completa
                    if lastQuestProgress > 0 and currentProgress == 0 then
                        needsNewQuest = true
                        
                    elseif currentProgress > 0 and (currentProgress ~= lastQuestProgress) then
                        -- Si hay progreso activo, notificar ocasionalmente
                        if math.random(1, 10) == 1 then
                            
                        end
                    end
                    
                    -- Actualizar el último progreso conocido
                    lastQuestProgress = currentProgress
                end
            end
        end)
        
        -- Si se detectó "0/5" después de tener progreso, o si no hay misión activa
        return needsNewQuest
    end

    -- Modificar el bucle de verificación periódica
    task.spawn(function()
        local lastQuestCheck = tick()
        local questCheckCooldown = 10 -- Verificar cada 10 segundos
        
        while _G.KaitunActive do
            local currentTime = tick()
            
            -- Verificación normal
            if currentTime - lastQuestCheck >= questCheckCooldown then
                lastQuestCheck = currentTime
                
                -- Verificar si estamos en la zona de farmeo
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local farmPos = Vector3.new(7820, -2160, -17145)
                    local distToFarm = (player.Character.HumanoidRootPart.Position - farmPos).Magnitude
                    
                    if distToFarm <= 50 and not isMissionCycleActive then
                        -- Usar pcall para evitar errores de thread
                        pcall(function()
                            local needsQuest = checkQuestProgress()
                            
                            if needsQuest then
                                isMissionCycleActive = true
                                -- Pausar el disparo temporalmente
                                lastShot = tick() + 10
                                performQuestCycle()
                                task.wait(1)
                                isMissionCycleActive = false
                            end
                        end)
                    end
                end
            end
            
            task.wait(1)
        end
    end)

    -- Corregir función para Gun Mastery (límite 500)
    task.spawn(function()
        -- Variable para seguimiento de estado de GunMastery
        local masteryCompleted = false
        
        while true do
            if _G.KaitunActive and not masteryCompleted then
                pcall(function()
                    -- Abrir menú de estadísticas si no está abierto
                    local statsGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Statistics")
                    
                    
                    -- Obtener valor actual de Gun Mastery
                    local currentMastery = 0
                    local success = pcall(function()
                        local statsGui = game:GetService("Players").LocalPlayer.PlayerGui.Statistics
                        if not statsGui then return end
                        
                        local main = statsGui.Main
                        if not main then return end
                        
                        local stats = main.Stats
                        if not stats then return end
                        
                        local gunMastery = stats.GunMastery
                        if not gunMastery then return end
                        
                        local amountLabel = gunMastery.Amount
                        if not amountLabel then return end
                        
                        -- Intentar diferentes formas de obtener el valor
                        local masteryText = amountLabel.Text or amountLabel.ContentText or ""
                        currentMastery = tonumber(string.match(masteryText, "%d+")) or 0
                    end)
                    
                    -- Verificar si ya alcanzamos el límite
                    if currentMastery >= 500 then
                        Window:Notify({
                            Title = "GunMastery completo",
                            Description = "¡Alcanzado 500/500 GunMastery!",
                            Lifetime = 5
                        })
                        masteryCompleted = true
                        return
                    end
                    
                    -- Obtener puntos disponibles
                    local points = 0
                    pcall(function()
                        local statsGui = game:GetService("Players").LocalPlayer.PlayerGui.Statistics
                        if not statsGui then return end
                        
                        local main = statsGui.Main
                        if not main then return end
                        
                        local topOptions = main.TopOptions
                        if not topOptions then return end
                        
                        local availableSPLabel = topOptions.AvailableSP
                        if not availableSPLabel then return end
                        
                        local pointsText = availableSPLabel.Text
                        points = tonumber(pointsText:match("(%d+)")) or 0
                    end)
                    
                    
                    
                    -- Aplicar punto solo si no hemos alcanzado 500
                    local args = {
                        [1] = "GunMastery",
                        [2] = nil,
                        [3] = 1
                    }
                    
                    local success = pcall(function()
                        game:GetService("ReplicatedStorage").Events.stats:FireServer(unpack(args))
                    end)
                    
                    if success and math.random(1, 5) == 1 then -- Mostrar solo ocasionalmente
                        
                    end
                end)
                
                task.wait(0.5) -- Medio segundo entre intentos para ser más eficiente
            else
                task.wait(2) -- Esperar más tiempo cuando está inactivo o ya completado
            end
        end
    end)

    local shootConfig = {
        autoReload = true,
        checkRaycast = false,
        targetPart = "Head",
        visualizeTarget = true,
        range = math.huge
    }

    local function createTargetMarker()
        -- Si ya existe, no crear de nuevo
        if targetMarker and targetMarker.Parent then return end
        
        -- Crear una sola vez en un pcall para evitar errores
        local success = pcall(function()
            targetMarker = Instance.new("Part")
            targetMarker.Anchored = true
            targetMarker.CanCollide = false
            targetMarker.Size = Vector3.new(0.5, 0.5, 0.5)
            targetMarker.Color = Color3.fromRGB(255, 0, 0)
            targetMarker.Material = Enum.Material.Neon
            targetMarker.Shape = Enum.PartType.Ball
            targetMarker.Transparency = 0.5
            
            -- Verificar si workspace existe antes de continuar
            if workspace then
                targetMarker.Parent = workspace
            else
                warn("Workspace no disponible para agregar targetMarker")
                return
            end
            
            -- Configurar para que se autodestruya si _G.KaitunActive se desactiva
            task.spawn(function()
                while targetMarker and targetMarker.Parent do
                    if not _G.KaitunActive then
                        if targetMarker and targetMarker.Parent then
                            targetMarker:Destroy()
                            targetMarker = nil
                        end
                        return -- Usar return en lugar de break
                    end
                    task.wait(1)
                end
            end)
        end)
        
        if not success then
            
        end
    end

    local function findClosestTarget()
        -- Usar pcall para evitar errores
        local success, result = pcall(function()
            local closestDistance = shootConfig.range
            local closest = nil
            
            -- Verificar si hay NPCs antes de iterar
            if not workspace or not workspace:FindFirstChild("NPCs") then 
                return nil 
            end
            
            -- Cache local para almacenar piezas objetivo ya encontradas
            local targetParts = {}
            
            -- Solo buscar en los hijos directos para evitar GetDescendants
            for _, npc in ipairs(workspace.NPCs:GetChildren()) do
                -- Verificación rápida del nombre
                if npc and npc.Name == "Fishman Karate User" then
                    -- Verificar la humanoid solo una vez
                    local humanoid = npc:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        -- Obtener SÓLO la parte "Head"
                        local headPart = targetParts[npc] or npc:FindFirstChild("Head")
                        
                        -- Guardar en caché para futuras referencias
                        if headPart then targetParts[npc] = headPart end
                        
                        if headPart and player and player.Character and 
                           player.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (player.Character.HumanoidRootPart.Position - headPart.Position).Magnitude
                            
                            -- Evitar raycast si no es necesario
                            local canSee = true
                            if shootConfig.checkRaycast and distance < closestDistance then
                                local ray = Ray.new(player.Character.HumanoidRootPart.Position, 
                                                   headPart.Position - player.Character.HumanoidRootPart.Position)
                                local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                canSee = hit == nil
                            end
                            
                            if distance < closestDistance and canSee then
                                closestDistance = distance
                                closest = {npc = npc, part = headPart, distance = distance}
                            end
                        end
                    end
                end
            end
            
            return closest
        end)
        
        if not success then
            warn("Error en findClosestTarget:", result)
            return nil
        end
        
        return result
    end

    local function reloadRifle()
        -- Si ya está recargando, no intentar recargar de nuevo
        if isReloading then return false end
        
        -- Marcar como recargando
        isReloading = true
        
        -- Preparar argumentos
        local args = {
            [1] = "reload",
            [2] = { ["Gun"] = "Rifle" }
        }
        
        -- Intentar recargar con pcall para evitar errores
        local success = false
        task.spawn(function()
            success = pcall(function()
                if not game:GetService("ReplicatedStorage") or
                   not game:GetService("ReplicatedStorage"):FindFirstChild("Events") or
                   not game:GetService("ReplicatedStorage").Events:FindFirstChild("CIcklcon") or
                   not game:GetService("ReplicatedStorage").Events.CIcklcon:FindFirstChild("gunFunctions") then
                    return false
                end
                
                return game:GetService("ReplicatedStorage").Events.CIcklcon.gunFunctions:InvokeServer(unpack(args))
            end)
            
            -- Asegurar que isReloading vuelva a false después de 1 segundo, incluso si falla
            task.delay(0.2, function() 
                isReloading = false
            end)
        end)
        
        return success
    end

    local function shootTarget(target)
        -- Usar pcall para seguridad
        local success, result = pcall(function()
            if not target or not target.part then return false end
            
            -- Comprobación de cooldown para reducir llamadas
            local currentTime = tick()
            if currentTime - lastShot < 0.2 then return false end
            
            -- Verificar que tenemos el rifle equipado
            if not player or not player.Character then return false end
            
            local rifleGun = player.Character:FindFirstChild("RifleGun")
            if not rifleGun or not rifleGun:FindFirstChild("Hole") then return false end
            
            -- Solo actualizar lastShot si realmente vamos a disparar
            lastShot = currentTime
            
            -- Preparar los argumentos una sola vez
            local args1 = {
                [1] = "fire",
                [2] = {
                    ["Start"] = rifleGun.Hole.CFrame,
                    ["Gun"] = "Rifle",
                    ["joe"] = "true",
                    ["Position"] = target.part.Position
                }
            }
            
            -- Usar pcall para la primera llamada
            local success1 = pcall(function()
                if not game:GetService("ReplicatedStorage") or
                   not game:GetService("ReplicatedStorage"):FindFirstChild("Events") or
                   not game:GetService("ReplicatedStorage").Events:FindFirstChild("CIcklcon") then
                    return false
                end
                
                game:GetService("ReplicatedStorage").Events.CIcklcon:FireServer(unpack(args1))
                return true
            end)

            -- Solo ejecutar el segundo disparo si el primero tuvo éxito
            if success1 then
                -- Intentar conseguir el RemoteEvent una sola vez con caché
                local guncastRemote = game:GetService("ReplicatedStorage"):FindFirstChild("guncast", true)
                if guncastRemote and guncastRemote:IsA("RemoteEvent") then
                    local args2 = {
                        [1] = target.part.Position,
                        [2] = target.part,
                        [3] = 0.1
                    }
                    pcall(function()
                        guncastRemote:FireServer(unpack(args2))
                    end)
                end
            end
            
            return success1
        end)
        
        if not success then
            warn("Error en shootTarget:", result)
            return false
        end
        
        return result
    end

    local function mainLoop()
        -- Usar pcall en todo el mainLoop para evitar errores fatales
        pcall(function()
            if shootConfig.visualizeTarget then
                createTargetMarker()
            end
            
            -- Variables para throttling y optimización
            local lastTargetCheck = 0
            local targetCheckCooldown = 0.1  -- Verificar objetivo cada 100ms
            local currentTarget = nil
            local consecutiveFails = 0
            local maxConsecutiveFails = 5
            
            -- Crear una única conexión para el Heartbeat con protección
            local connection
            local connectionSuccess = pcall(function()
                connection = runService.Heartbeat:Connect(function()
                    -- Usar pcall en el callback para evitar que un error detenga todo el script
                    pcall(function()
                        -- Si se desactiva el auto farm o hay un ciclo de misión activo, pausar temporalmente
                        if not _G.KaitunActive or isMissionCycleActive then
                            if not _G.KaitunActive and connection then
                                connection:Disconnect()
                                connection = nil
                                autoShootingStarted = false
                                if targetMarker and targetMarker.Parent then
                                    targetMarker:Destroy()
                                    targetMarker = nil
                                end
                            end
                            return -- Usar return en lugar de break
                        end

                        -- Verificaciones de throttling
                        local currentTime = tick()
                        
                        -- Solo comprobar el carácter a intervalos regulares
                        if not player then return end
                        local character = player.Character
                        if not character then return end
                        
                        local rifleGun = character:FindFirstChild("RifleGun")
                        if not rifleGun then return end
                        
                        -- Comprobar objetivo solo periódicamente para reducir carga
                        if currentTime - lastTargetCheck >= targetCheckCooldown then
                            lastTargetCheck = currentTime
                            currentTarget = findClosestTarget()
                            
                            -- Actualizar el marcador visual solo cuando cambia el objetivo
                            if targetMarker and targetMarker.Parent and currentTarget and currentTarget.part then
                                targetMarker.Position = currentTarget.part.Position
                                targetMarker.Transparency = 0.5
                            elseif targetMarker and targetMarker.Parent then
                                targetMarker.Transparency = 1
                            end
                        end
                        
                        -- Solo disparar si hay un objetivo válido
                        if currentTarget then
                            local success = shootTarget(currentTarget)
                            if success then
                                consecutiveFails = 0
                            else
                                consecutiveFails = consecutiveFails + 1
                                -- Si hay demasiados fallos consecutivos, intentar recargar
                                if consecutiveFails >= maxConsecutiveFails and shootConfig.autoReload then
                                    reloadRifle()
                                    consecutiveFails = 0
                                end
                            end
                        end
                    end)
                end)
            end)
            
            -- Si no se pudo crear la conexión, notificar
            if not connectionSuccess or not connection then
                
            end
        end)
    end

    -- Iniciar el mainLoop con protección adicional
    pcall(mainLoop)

end

-- Funciones básicas necesarias
local function checkPeli()
    -- Verifica si PlayerGui y HUD existen
    if not player or not player:FindFirstChild("PlayerGui") then return false end
    if not player.PlayerGui:FindFirstChild("HUD") then return false end
    if not player.PlayerGui.HUD:FindFirstChild("Main") then return false end
    if not player.PlayerGui.HUD.Main:FindFirstChild("Peli") then return false end
    if not player.PlayerGui.HUD.Main.Peli:FindFirstChild("TextLabel") then return false end

    -- Extraer solo los números del texto
    local peliLabel = player.PlayerGui.HUD.Main.Peli.TextLabel
    local peliAmount = peliLabel.Text:gsub("%D", "")
    
    return tonumber(peliAmount) or 0
end


local function checkGun()
    if player.Backpack:FindFirstChild("Rifle") or (player.Character and player.Character:FindFirstChild("Rifle")) then
        return true
    end
    return false
end

local function checkMega()
    if player.Backpack:FindFirstChild("Mega-Pow") or (player.Character and player.Character:FindFirstChild("Mega-Pow")) then
        return true
    end
    return false
end



-- Función corregida para calcular la duración del tween


-- Función simple para comprar rifle
local function getRifle()
    pcall(function()
        ReplicatedStorage:WaitForChild("Events"):WaitForChild("Tools"):InvokeServer("equip", "Rifle")
    end)
    return checkGun()
end

-- Función mejorada para teleport con triple intento y reset
local function teleportToRifleArea()
    -- Si ya tiene el rifle equipado y está en posición de farmeo, simplemente retornar
    if player.Character and player.Character:FindFirstChild("RifleGun") then
        -- No mostrar notificación aquí
        return true
    end
    
    local TweenService = game:GetService('TweenService')
    local targetPosition = Vector3.new(7982, -2149, -17075)
    if _G.KaitunActive and checkGun() then
        local currentPos = player.Character.HumanoidRootPart.Position


            
        Window:Notify({ Title = "Auto Farm", Description = "Teleported to final position", Lifetime = 3 })

            if (currentPos - targetPosition).Magnitude <= 500 then
                local bv2 = Instance.new("BodyVelocity")
                bv2.Velocity = Vector3.new(0, 0, 0)
                bv2.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv2.Parent = player.Character.HumanoidRootPart
                local newPos = Vector3.new(currentPos.X, currentPos.Y + 15, currentPos.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(newPos)
                task.wait(0.5)  -- Pequeña pausa para estabilizar
                
                local tweenTarget = Vector3.new(7820, newPos.Y, -17145)
                local tweenDuration = calcularDuracionTween(newPos, tweenTarget, 35)
                local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
                local tween = createTween(player.Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(tweenTarget)}, true)
                tween:Play()
                tween.Completed:Wait()
                
                local finalPos = Vector3.new(tweenTarget.X, -2160, tweenTarget.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                bv2:Destroy()
    
                -- Insertado: Simulación de keypress si se encuentra 'Rifle' en el Hotbar
                equipWeapon("Rifle")
            return true
        end
    end
    
    local success = false
    
    -- No limitamos intentos, seguiremos hasta tener éxito
    while not success do
        -- Realizamos 3 ciclos de teleport + reset
        for i = 1, 3 do
            -- Teleport inicial al área
            pcall(function()
                player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
                task.wait(0.2) -- Pequeña pausa para estabilizar
                
                -- Reset del personaje
                ReplicatedStorage:WaitForChild("Events"):WaitForChild("KnockedOut"):FireServer("self")
                task.wait(0.3) -- Esperar después del KnockedOut
                
                -- Notificar el intento actual
                Window:Notify({
                    Title = "Attempt " .. i .. "/3",
                    Description = "Teleport + Reset completed",
                    Lifetime = 2
                })
            end)
            
            -- Pequeña pausa entre ciclos
            task.wait(1)
        end
        
        -- Verificar si permanece en el área durante 25 segundos
        local startTime = tick()
        local inArea = true
        
        -- Notificar al usuario que estamos verificando
        Window:Notify({
            Title = "Checking position",
            Description = "Waiting for stability (25s)...",
            Lifetime = 3
        })
        
        -- Loop de verificación durante 25 segundos
        while tick() - startTime < 25 and inArea do
            -- Comprobar si sigue en el área (radio 50)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local currentPos = player.Character.HumanoidRootPart.Position
                local distance = (currentPos - targetPosition).Magnitude
                
                if distance > 50 then
                    inArea = false
                    Window:Notify({
                        Title = "Out of area",
                        Description = "Retrying teleport in 30 seconds...",
                        Lifetime = 5
                    })
                end
            else
                inArea = false
            end
            
            task.wait(0.5) -- Comprobar cada 0.5 segundos
        end
        
        -- Si completó los 25 segundos en el área, marcar como éxito
        if inArea then
            local currentPos = player.Character.HumanoidRootPart.Position
            local checkPos = Vector3.new(7982, -2149, -17075)
            local distance = (currentPos - checkPos).Magnitude

            -- Primero establecemos el spawn point
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("SetSpawn"):FireServer()
            wait(0.5)
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("SetSpawn"):FireServer()
            wait(0.5)
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("SetSpawn"):FireServer()
            wait(2)
            Window:Notify({ Title = "Success", Description = "Spawn point set successfully", Lifetime = 3 })
            
            -- Luego hacemos el tween a la posición de farmeo
            if distance <= 500 then
                -- Crear BodyVelocity para evitar caídas
                local bv2 = Instance.new("BodyVelocity")
                bv2.Velocity = Vector3.new(0, 0, 0)
                bv2.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv2.Parent = player.Character.HumanoidRootPart

                -- Elevación inicial
                local newPos = Vector3.new(currentPos.X, currentPos.Y + 200, currentPos.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(newPos)
                task.wait(0.5)

                -- Tween a la posición de farmeo
                local tweenTarget = Vector3.new(7820, newPos.Y, -17145)
                local tweenDuration = calcularDuracionTween(newPos, tweenTarget, 35)
                local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
                local tween = createTween(player.Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(tweenTarget)}, true)
                tween:Play()
                tween.Completed:Wait()

                -- Posición final
                local finalPos = Vector3.new(tweenTarget.X, -2160, tweenTarget.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                bv2:Destroy()

                Window:Notify({ Title = "Success", Description = "Moved to farming position", Lifetime = 3 })
            end
            success = true
        else
            -- Esperar 30 segundos antes de reintentar
            Window:Notify({
                Title = "Waiting",
                Description = "Waiting 30 seconds before retrying...",
                Lifetime = 10
            })
            
            local waitStartTime = tick()
            while tick() - waitStartTime < 30 do
                if math.floor(tick() - waitStartTime) % 5 == 0 then
                    local timeLeft = 30 - math.floor(tick() - waitStartTime)
                    Window:Notify({ Title = "Countdown", Description = "Retrying in " .. timeLeft .. " seconds", Lifetime = 2 })
                end
                task.wait(1)
            end
            Window:Notify({ Title = "Retrying", Description = "Retrying teleport...", Lifetime = 3 })
        end
    end
    
    return success
end

-- Función para obtener islas
local function getIslands()
    local islandList = {}
    if workspace:FindFirstChild("Islands") then
        for _, island in pairs(workspace.Islands:GetChildren()) do
            table.insert(islandList, island.Name)
        end
    end
    
    if #islandList == 0 then
        table.insert(islandList, "No Islands Found")
    end
    
    return islandList
end

-- Variable para isla seleccionada
local currentSelectedIsland = ""


-- TAB MAIN - Solo 3 elementos
-- 1. Estado de Pelis - Corregir título

local link = "discord.gg/yWmNNmffgq"

local tabGroups = {
	TabGroup1 = Window:TabGroup()
}

local tabs = {
	Welcome = tabGroups.TabGroup1:Tab({ Name = "Welcome", Image = "rbxassetid://18821914323" }),
    Main = tabGroups.TabGroup1:Tab({ Name = "Farms", Image = "rbxassetid://18821914323" }),
    teleports = tabGroups.TabGroup1:Tab({ Name = "Teleports", Image = "rbxassetid://18821914323" }),
    misc = tabGroups.TabGroup1:Tab({ Name = "Misc", Image = "rbxassetid://18821914323" }),
	Settings = tabGroups.TabGroup1:Tab({ Name = "Settings", Image = "rbxassetid://10734950309" })
}

local sections = {
    welcomeSection = tabs.Welcome:Section({ Side = "Left" }),
    welcomeSectionDiscord = tabs.Welcome:Section({ Side = "right" }),
    welcomeSectionDevs = tabs.Welcome:Section({ Side = "right" }),
    welcomeSectionFarmsStatus = tabs.Welcome:Section({ Side = "Left" }),
    welcomeSectionFarmAnniversary = tabs.Main:Section({ Side = "right" }),
	MainSection1 = tabs.Main:Section({ Side = "Left" }),
    teleports = tabs.teleports:Section({ Side = "Left" }),
    teleportsMain = tabs.teleports:Section({ Side = "right" }),
    priv = tabs.misc:Section({ Side = "Left" }),
}

sections.welcomeSection:Header({
	Name = "Welcome to Ousi.HUB!"
})

sections.welcomeSection:Paragraph({
	Header = "Join to our Discord server!",
	Body = "discord.gg/yWmNNmffgq <- JOIN"
})

sections.welcomeSectionDiscord:Button({
	Name = "Copy discord link :)",
	Callback = function()
		setclipboard(link)
	end,
})
sections.priv:Button({
	Name = "Buy geppo",
	Callback = function()
		local args = {
            [1] = "skyWalkTrainer"
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("learnStyle"):FireServer(unpack(args))
	end,
})

sections.welcomeSectionDevs:Header({
	Name = "Script DEVELOPERS",
})

sections.welcomeSectionDevs:Label({
	Text = "-(((KOKI💖)))"
})
sections.welcomeSectionDevs:Label({
	Text = "-????"
})

sections.welcomeSectionFarmsStatus:Header({
	Name = "Script status",
})

sections.welcomeSectionFarmsStatus:Paragraph({
	Header = "Kaitun Status->✅",
	Body = "Working good!:)"
})



sections.welcomeSectionFarmsStatus:Paragraph({
	Header = "Anniversary Status->🟦",
	Body = "Open Test!"
})

sections.welcomeSectionFarmsStatus:Paragraph({
	Header = "Cupid Status->🟧",
	Body = "In progress!"
})








sections.MainSection1:Header({
	Name = "AutoLevel Kaitun",
})

-- Sistema de notificaciones de depuración que se muestran solo una vez
local debugNotifications = {}

-- Función para mostrar notificaciones de depuración solo una vez
local function debugNotify(id, title, description, lifetime)
    if not debugNotifications[id] then
        Window:Notify({
            Title = title or "Debug",
            Description = description or "",
            Lifetime = lifetime or 3
        })
        debugNotifications[id] = true
    end
end



-- Store the reference to the Paragraph element
local RifleStatus = sections.MainSection1:Paragraph({
	Header = "Rifle?",
	Body = "Loading..."
})

local PeliStatus = sections.MainSection1:Paragraph({
	Header = "Peli?",
	Body = "Loading..."
})

sections.MainSection1:Toggle({
	Name = "Kaitun",
	Default = false,
	Callback = function(value)
        print(value)
		_G.KaitunActive = value
		Window:Notify({
			Title = "Ousi.HUB",
			Description = (value and "Enabled " or "Disabled ") .. "AutloLevel Kaitun"
		})
	end,
}, "KaitunToggle")



-- Set up a proper timer to call the update function periodically




sections.welcomeSectionFarmAnniversary:Header({
	Name = "AutoAnniversary",
})

local megaStatus = sections.welcomeSectionFarmAnniversary:Paragraph({
	Header = "Mega-Pow?",
	Body = "✅"
})

if debug then

    waveParagraph = sections.welcomeSectionFarmAnniversary:Paragraph({
        Header = "Control de Waves",
        Body = "Wave " .. tostring(wave) .. "!"
    })


    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 1",
        Callback = function()
            wave = 1
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 1!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 1",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 2",
        Callback = function()
            wave = 2
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 2!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 2",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 3",
        Callback = function()
            wave = 3
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 3!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 3",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 4",
        Callback = function()
            wave = 4
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 4!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 4",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 5",
        Callback = function()
            wave = 5
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 5!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 5",
                Lifetime = 3
            })
            end
        end
    })
end

task.spawn(function()
    while true do
        local success, err = pcall(function()
            local hasRifle = checkGun()
            local hasMega = checkMega()
            local peliAmount = checkPeli()
            
            if debug then
                print("Iteración de actualización:", hasRifle, peliAmount, hasMega)  -- Depuración
            end

            RifleStatus:UpdateBody(hasRifle and "✅ Equipped" or "❌ Not Equipped")
            megaStatus:UpdateBody(hasMega and "✅ Equipped" or "❌ Not Equipped")

            
            local peliDisplay = "❌ no peli for rifle"
            if type(peliAmount) == "number" and peliAmount >= 300 then
                peliDisplay = "✅ " .. peliAmount .. " Peli"
            end
            PeliStatus:UpdateBody(peliDisplay)
            
            if not hasUpdatedOnce then
                if debug then
                    debugNotify("first_auto_update", "Auto Update", 
                        "First auto update completed. Rifle: " .. (hasRifle and "Yes" or "No") ..
                        ", Peli: " .. (type(peliAmount) == "number" and peliAmount or "N/A"), 3)
                end
                hasUpdatedOnce = true
            end
        end)
        if not success then
            warn("Error en la actualización automática:", err)
        end
        
        task.wait(2)
    end
end)





sections.welcomeSectionFarmAnniversary:Toggle({
    Name = "Anniversary",
    Default = false,
    Callback = function(value)
        farm = value
        print(farm)
        if farm then

            





            local function gpo()
                local args = {
                    [1] = "Sky Walk2",
                    [2] = {
                        ["char"] = game.Players.LocalPlayer.Character,
                        ["cf"] = CFrame.new(-6629.06103515625, 17.600412368774414, -4605.69873046875, 0, 1, -0, 0, -0, -1, -1, 0, -0)
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Skill"):InvokeServer(unpack(args))
            end
            
            local gpoRunning = false
            local function startGpoContinuous()
                if gpoRunning then return end
                gpoRunning = true
                
                task.spawn(function()
                    while farm do
                        pcall(function() gpo() end)
                        wait(2)
                    end
                    gpoRunning = false
                end)
            end

            -- Iniciar el Sky Walk2 continuo
            startGpoContinuous()
            
            if game.PlaceId == 3978370137 then
                tween(Vector3.new(-6570, 11, -4599))
            else 
                StartFarm()
            end
        else
            -- Desconectar Heartbeat al desactivar el toggle
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
            
            if debug then
                print("Control de Waves desactivado")
            end
        end
    end,
}, "Anniversary")




sections.teleports:Header({
	Name = "Teleport to islands",
})

local islandDropdown = sections.teleports:Dropdown({
    Name = "Teleports",
    Search = true,
    Options = getIslands(),
    Callback = function(Value)
        -- For single selection dropdowns, Value is the selected option name
        currentSelectedIsland = Value
        
        -- Optional: Show notification when island is selected
        Window:Notify({
            Title = "Island Selected",
            Description = "Selected: " .. Value,
            Lifetime = 2
        })
    end,
})

sections.teleports:Button({
	Name = "Teleport to island",
	Callback = function()
		if currentSelectedIsland and currentSelectedIsland ~= "" and currentSelectedIsland ~= "No Islands Found" then
            local targetIsland = workspace.Islands:FindFirstChild(currentSelectedIsland)
            if targetIsland then
                -- Notificar al usuario
                Window:Notify({
                    Title = "Teleport",
                    Description = "Teleporting to " .. currentSelectedIsland,
                    Lifetime = 3
                })
                
                -- Obtener posición de la isla usando atributos
                local islandPosition = nil
                
                -- Usar pcall para evitar errores al obtener atributos
                pcall(function()
                    -- Comprobar islandCFrame (puede ser CFrame o string)
                    local islandCFrameAttr = targetIsland:GetAttribute("islandCFrame")
                    if islandCFrameAttr then
                        -- Si es un CFrame directo
                        if typeof(islandCFrameAttr) == "CFrame" then
                            islandPosition = islandCFrameAttr.Position
                        -- Si es un string que representa coordenadas
                        elseif typeof(islandCFrameAttr) == "string" then
                            local x, y, z = string.match(islandCFrameAttr, "(-?%d+%.?%d*),? *(-?%d+%.?%d*),? *(-?%d+%.?%d*)")
                            if x and y and z then
                                islandPosition = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                            end
                        end
                    end
                    
                    -- Si no se pudo obtener con islandCFrame, intentar con islandPosition
                    if not islandPosition then
                        local islandPosAttr = targetIsland:GetAttribute("islandPosition")
                        if islandPosAttr then
                            -- Si es un Vector3 directo
                            if typeof(islandPosAttr) == "Vector3" then
                                islandPosition = islandPosAttr
                            -- Si es un string que representa coordenadas
                            elseif typeof(islandPosAttr) == "string" then
                                local x, y, z = string.match(islandPosAttr, "(-?%d+%.?%d*),? *(-?%d+%.?%d*),? *(-?%d+%.?%d*)")
                                if x and y and z then
                                    islandPosition = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                                end
                            end
                        end
                    end
                    
                    -- Si no se pudo obtener con atributos, intentar con WorldPivot
                    if not islandPosition then
                        local worldPivot = targetIsland:GetPivot()
                        islandPosition = worldPivot.Position
                    end
                end)
                
                -- Si aún no tenemos posición, buscar en PrimaryPart o cualquier parte
                if not islandPosition then
                    pcall(function()
                        if targetIsland.PrimaryPart then
                            islandPosition = targetIsland.PrimaryPart.Position
                        else
                            -- Buscar cualquier parte y usar su posición
                            for _, part in pairs(targetIsland:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    islandPosition = part.Position
                                    break
                                end
                            end
                        end
                    end)
                end
                
                -- Verificar que tenemos una posición válida
                if islandPosition then
                    -- Poner offset en Y para evitar quedar dentro del terreno
                    local finalPos = Vector3.new(islandPosition.X, islandPosition.Y + 1000, islandPosition.Z)
                    
                    -- Usar la estructura exacta solicitada
                    pcall(function()
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                        task.wait(0.1) -- Pequeña pausa para estabilizar
                        
                        -- Reset del personaje
                        ReplicatedStorage:WaitForChild("Events"):WaitForChild("KnockedOut"):FireServer("self")
                        task.wait(0.3) -- Esperar después del KnockedOut
                        
                        -- Notificar al usuario
                        Window:Notify({
                            Title = "Teleport + Reset",
                            Description = "Teleport to " .. currentSelectedIsland .. " completed",
                            Lifetime = 2
                        })
                    end)
                else
                    Window:Notify({
                        Title = "Teleport error",
                        Description = "Island not found in workspace",
                        Lifetime = 3
                    })
                end
            else
                Window:Notify({
                    Title = "Teleport error",
                    Description = "Island not found in workspace",
                    Lifetime = 3
                })
            end
        else
            Window:Notify({
                Title = "Teleport error",
                Description = "Please select an island first",
                Lifetime = 3
            })
        end
	end,
})

sections.teleportsMain:Header({
	Name = "Teleport to main game",
})

sections.teleportsMain:Button({
	Name = "Teleport to main game",
	Callback = function()

        local TeleportService = game:GetService("TeleportService")
        local placeId = 3978370137
        TeleportService:Teleport(placeId)
    end
})

sections.teleportsMain:Button({
	Name = "Teleport to main menu",
	Callback = function()

        local TeleportService = game:GetService("TeleportService")
        local placeId = 1730877806
        TeleportService:Teleport(placeId)
    end
})



-- Añadimos las funciones para cofres
local TweenService = game:GetService("TweenService")

-- Versión optimizada con tweens basados en velocidad constante de 35

-- Función para encontrar el cofre más cercano y evitar repetición
local coffresUsados = {}  -- Tabla para rastrear cofres ya usados

local function findNearestChest()
    local nearestChest = nil
    local minDistance = math.huge
    
    -- Buscar cofres en workspace.Env
    if workspace:FindFirstChild("Env") then
        for _, v in pairs(workspace.Env:GetDescendants()) do
            if v.Name == "Chest" or v.Name:lower():find("chest") or v.Name:lower():find("cofre") then
                -- Verificar si ya fue usado
                if not coffresUsados[v] and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (v:GetPivot().Position - player.Character.HumanoidRootPart.Position).Magnitude
                    if distance < minDistance then
                        minDistance = distance
                        nearestChest = v
                    end
                end
            end
        end
    end
    
    return nearestChest
end

-- Función para interactuar con prompts cercanos
local function interactWithPromptOnce()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    
    local humanoidRootPart = player.Character.HumanoidRootPart
    local interacted = false
    
    for _, prompt in pairs(workspace:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") and prompt.Name == "ProximityPrompt" then
            local distance = (prompt.Parent:IsA("Part") and (prompt.Parent.Position - humanoidRootPart.Position).Magnitude or math.huge)
            if distance <= 5 and prompt.Enabled then
                fireproximityprompt(prompt, prompt.HoldDuration)

                interacted = true
                break
            end
        end
    end
    
    return interacted
end

-- Función optimizada para moverse a cofres con velocidad constante
local function tweenToChest(chest)
    if not chest or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    
    -- Crear BodyVelocity para no caer
    local bv = Instance.new("BodyVelocity")
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Parent = player.Character.HumanoidRootPart
    
    -- Primera etapa: TP directo a Y=200 (misma XZ)
    local currentPos = player.Character.HumanoidRootPart.Position
    local highPos = Vector3.new(currentPos.X, 15, currentPos.Z)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(highPos)
    task.wait(0.1)  -- Pequeña pausa para estabilizar
    
    -- Segunda etapa: tween a XZ del cofre a velocidad constante de 35
    local chestPos = chest:GetPivot().Position
    local targetPosXZ = Vector3.new(chestPos.X, 15, chestPos.Z)
    
    -- Calcular duración basada en velocidad constante de 35
    local duracion = calcularDuracionTween(highPos, targetPosXZ, 35)
    
    local tweenInfoXZ = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
    local tweenXZ = createTween(player.Character.HumanoidRootPart, tweenInfoXZ, {CFrame = CFrame.new(targetPosXZ)}, true)
    
    tweenXZ:Play()
    tweenXZ.Completed:Wait()
    
    -- Tercera etapa: TP directo a Y+3 del cofre
    local finalPos = Vector3.new(chestPos.X, chestPos.Y + 3, chestPos.Z)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
    
    -- Activar ProximityPrompt 
    task.wait(0.3)
    local success = interactWithPromptOnce()
    
    -- Marcar el cofre como usado si tuvimos éxito
    if success then
        coffresUsados[chest] = true
    end
    
    -- Eliminar BodyVelocity
    task.wait(0.5)  -- Reducido tiempo de espera
    if bv and bv.Parent then
        bv:Destroy()
    end
    
    return success
end

-- Nueva función para comprar el rifle desde la tienda
local function buyRifleFromShop()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    
    -- Crear BodyVelocity para no caer
    local bv = Instance.new("BodyVelocity")
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Parent = player.Character.HumanoidRootPart
    
    -- Tween para subir a Y=200 (en lugar de TP directo)
    local currentPos = player.Character.HumanoidRootPart.Position
    local elevatedPos = Vector3.new(currentPos.X, 15, currentPos.Z)
    
    -- Calcular duración para el tween vertical (velocidad 20)
    local verticalDistance = math.abs(currentPos.Y - 200)
    local verticalDuration = verticalDistance / 20
    
    local tweenInfoY = TweenInfo.new(verticalDuration, Enum.EasingStyle.Linear)
    local tweenY = createTween(player.Character.HumanoidRootPart, tweenInfoY, {CFrame = CFrame.new(elevatedPos)}, false)
    
    tweenY:Play()
    tweenY.Completed:Wait()
    task.wait(0.1)  -- Pequeña pausa para estabilizar
    
    -- Tween a las coordenadas (-531, 200, -3448) con velocidad constante
    local storeXZ = Vector3.new(-531, 15, -3448)
    local duracion = calcularDuracionTween(elevatedPos, storeXZ, 35)
    local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
    local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
    
    tweenStore:Play()
    tweenStore.Completed:Wait()
    
    -- Tween para bajar a Y=6 (en lugar de TP directo)
    local finalPos = Vector3.new(-531, 6, -3448)
    
    -- Calcular duración para el tween vertical de bajada (velocidad 20)
    local descendDistance = math.abs(200 - 6)
    local descendDuration = descendDistance / 20
    
    local tweenInfoDescend = TweenInfo.new(descendDuration, Enum.EasingStyle.Linear)
    local tweenDescend = createTween(player.Character.HumanoidRootPart, tweenInfoDescend, {CFrame = CFrame.new(finalPos)}, false)
    
    tweenDescend:Play()
    tweenDescend.Completed:Wait()
    
    -- Eliminar BodyVelocity
    if bv and bv.Parent then
        bv:Destroy()
    end
    
    task.wait(0.3)
    
    return checkGun()
end

-- Función corregida para comprar rifle (tween a XZ de la tienda, luego TP a Y+6)
local function buyAndEquipRifle()
    for i = 1, 5 do
        local args = {
            [1] = "equip",
            [2] = "Rifle"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Tools"):InvokeServer(unpack(args))
        task.wait(0.3)
    end
    return checkGun()
end

-- Nueva función para comprar el rifle desde la tienda
local function buyRifleFromShop()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    local currentPos = player.Character.HumanoidRootPart.Position
    local storeXZ = Vector3.new(-531, 15, -3448)
    local duracion = calcularDuracionTween(currentPos, storeXZ, 35)
    local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
    local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
    tweenStore:Play()
    tweenStore.Completed:Wait()
    
    -- Teletransportar a Y=200 instantáneamente
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local currentPos = player.Character.HumanoidRootPart.Position
        local bv = Instance.new("BodyVelocity")
        bv.Velocity = Vector3.new(0, 0, 0)
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = player.Character.HumanoidRootPart
        player.Character.HumanoidRootPart.CFrame = CFrame.new(currentPos.X, 15, currentPos.Z)
        task.wait(0.1)
        
        -- Tween a las coordenadas (-531, 200, -3448) con velocidad constante
        local storeXZ = Vector3.new(-531, 15, -3448)
        local duracion = calcularDuracionTween(currentPos, storeXZ, 35)
        local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
        local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
        tweenStore:Play()
        tweenStore.Completed:Wait()
        
        -- Teletransportar a Y=6 una vez llegado
        local finalPos = Vector3.new(-531, 6, -3448)
        player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
        bv:Destroy()
        task.wait(0.3)
    end
    
    local args = {
        [1] = workspace:WaitForChild("BuyableItems"):WaitForChild("Rifle"),
        [2] = 1
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Shop"):InvokeServer(unpack(args))
    task.wait(0.3)
    return checkGun()
end

-- Modificación en la lógica principal del Kaitun
-- Reemplazo en la sección donde, tras recolectar 300 pelis, se intenta comprar el rifle
task.spawn(function()
    while task.wait(1) do      
        if _G.KaitunActive then
            -- Intentar equipar el rifle 3 veces
            for i = 1, 3 do
                local args = { [1] = "equip", [2] = "Rifle" }
                game:GetService("ReplicatedStorage"):WaitForChild("Events")
                    :WaitForChild("Tools"):InvokeServer(unpack(args))
                task.wait(0.3)
            end
            
            -- Verificar si ya tenemos rifle y pelis suficientes
            local currentPelis = checkPeli()
            if checkGun() and currentPelis >= 300 then
                teleportToRifleArea()
                startAutoShooting()
                cancelAllActiveTweens(true)
            elseif checkGun() then
                -- Si tenemos rifle pero no pelis, ir directo a farmear
                teleportToRifleArea()
                startAutoShooting()
                cancelAllActiveTweens(true)
            else
                Window:Notify({
                    Title = "Kaitun Active",
                    Description = "Rifle not equipped, starting to farm Pelis...",
                    Lifetime = 2
                })
                
                -- Farmear cofres hasta tener 300 pelis
                while checkPeli() < 300 do
                    local nearestChest = findNearestChest()
                    if nearestChest then
                        Window:Notify({
                            Title = "Auto Farm",
                            Description = "Found a chest! Moving to collect...",
                            Lifetime = 2
                        })
                        local successChest = tweenToChest(nearestChest)
                        if not successChest then
                            Window:Notify({
                                Title = "Auto Farm",
                                Description = "Unable to collect chest, searching for another...",
                                Lifetime = 2
                            })
                            task.wait(2)
                        end
                    else
                        Window:Notify({
                            Title = "Auto Farm",
                            Description = "No chests found nearby. Searching...",
                            Lifetime = 3
                        })
                        task.wait(3)
                    end
                end
                
                -- Con suficientes pelis, se procede al proceso de compra del rifle
                Window:Notify({
                    Title = "Auto Farm",
                    Description = "Currency collected! Moving to shop...",
                    Lifetime = 2
                })
                
                -- Teletransportar a Y=200 instantáneamente
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local currentPos = player.Character.HumanoidRootPart.Position
                    local bv = Instance.new("BodyVelocity")
                    bv.Velocity = Vector3.new(0, 0, 0)
                    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    bv.Parent = player.Character.HumanoidRootPart
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(currentPos.X, 15, currentPos.Z)
                    task.wait(0.1)
                    
                    -- Tween a las coordenadas (-531, 200, -3448) con velocidad constante
                    local storeXZ = Vector3.new(-531, 15, -3448)
                    local duracion = calcularDuracionTween(currentPos, storeXZ, 35)
                    local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
                    local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
                    tweenStore:Play()
                    tweenStore.Completed:Wait()
                    
                    -- Teletransportar a Y=6 una vez llegado
                    local finalPos = Vector3.new(-531, 6, -3448)
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                    bv:Destroy()
                    task.wait(0.3)
                end
                
                -- Llamada al Shop para comprar el rifle 3 veces
                for j = 1, 3 do
                    local argsShop = { [1] = workspace:WaitForChild("BuyableItems"):WaitForChild("Rifle"), [2] = 1 }
                    game:GetService("ReplicatedStorage"):WaitForChild("Events")
                        :WaitForChild("Shop"):InvokeServer(unpack(argsShop))
                    task.wait(0.3)
                end
                
                -- Intentar equipar el rifle 3 veces
                for k = 1, 3 do
                    local argsEquip = { [1] = "equip", [2] = "Rifle" }
                    game:GetService("ReplicatedStorage"):WaitForChild("Events")
                        :WaitForChild("Tools"):InvokeServer(unpack(argsEquip))
                    task.wait(0.3)
                end
                
                if checkGun() then
                    Window:Notify({
                        Title = "Success",
                        Description = "Rifle acquired and equipped, teleporting...",
                        Lifetime = 3
                    })
                    task.wait(1)
                    teleportToRifleArea()
                    startAutoShooting()
                    cancelAllActiveTweens(true)
                else
                    Window:Notify({
                        Title = "Error",
                        Description = "Failed to acquire rifle",
                        Lifetime = 3
                    })
                end
            end
        end
        task.wait(1)
    end
end)

--[[





logica arriba







]]--






MacLib:SetFolder("gpo")
tabs.Settings:InsertConfigSection("Left")

Window.onUnloaded(function()
    _G.KaitunActive = false
	print("Unloaded!")
end)

tabs.Welcome:Select()
MacLib:LoadAutoLoadConfig()

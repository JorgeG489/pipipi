print("sssasdasdasd")
local success, result = pcall(function()
    return loadstring(game:HttpGet('https://raw.githubusercontent.com/Kokiuvu123/GPO/refs/heads/main/sadsadsad'))()
end)

if not success or result ~= true then
    game.Players.LocalPlayer:Kick("script down")
    return
end

local player = game:GetService("Players").LocalPlayer

-- Separar la l√≥gica en dos partes distintas
if game.PlaceId == 1730877806 then
    -- Primera parte: Esperar a que aparezca chooseType
    if getgenv().vipserver and getgenv().vipserver ~= "" then
        local priv = getgenv().vipserver
        print("vip server:" .. priv)
        
        task.spawn(function()
            -- Esperar a que el juego cargue completamente
            wait(3)
            
            -- Invocar el servidor privado hasta que aparezca chooseType
            while true do
                local chooseType = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("chooseType")
                
                if not chooseType then
                    print("sss?")
                    pcall(function()
                        game:GetService("ReplicatedStorage").Events.reserved:InvokeServer(priv)
                    end)
                    wait(2)
                else
                    print("yeahhhh!!")
                    break -- Salir del bucle cuando se encuentre chooseType
                end
            end
        end)
    end
end

-- Segunda parte: Activar el RemoteEvent una vez que chooseType exista
if game.PlaceId == 1730877806 then
    if getgenv().vipserver and getgenv().vipserver ~= "" then
        task.spawn(function()
            -- Esperar un poco para asegurar que la primera parte haya tenido tiempo de ejecutarse
            wait(5)
            
            -- Bucle para activar el RemoteEvent
            while true do
                local chooseType = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("chooseType")
                
                if chooseType then
                    print("11")
                    pcall(function()
                        local remoteEvent = chooseType.Frame:WaitForChild("RemoteEvent", 3)
                        if remoteEvent then
                            remoteEvent:FireServer(true)
                            print("2")
                            wait(5) -- Esperar m√°s tiempo despu√©s de activar
                        else
                            print("4")
                        end
                    end)
                end
                
                wait(3) -- Verificar peri√≥dicamente
            end
        end)
    end
end



local MacLib = loadstring(game:HttpGet("https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt"))()

local Window = MacLib:Window({
	Title = "Ousi.HUB",
	Subtitle = "By (((koki)))",
	Size = UDim2.fromOffset(590, 470),
	DragStyle = 2,
	DisabledWindowControls = {},
	ShowUserInfo = true,
	Keybind = Enum.KeyCode.LeftControl,
	AcrylicBlur = true,
})

local globalSettings = {
	UIBlurToggle = Window:GlobalSetting({
		Name = "UI Blur",
		Default = Window:GetAcrylicBlurState(),
		Callback = function(bool)
			Window:SetAcrylicBlurState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
				Lifetime = 5
			})
		end,
	}),
	NotificationToggler = Window:GlobalSetting({
		Name = "Notifications",
		Default = Window:GetNotificationsState(),
		Callback = function(bool)
			Window:SetNotificationsState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " Notifications",
				Lifetime = 5
			})
		end,
	}),
	ShowUserInfo = Window:GlobalSetting({
		Name = "Show User Info",
		Default = Window:GetUserInfoState(),
		Callback = function(bool)
			Window:SetUserInfoState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Showing" or "Redacted") .. " User Info",
				Lifetime = 5
			})
		end,
	})
}



local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local activeTweens = {}
local questTweens = {} -- Nueva tabla para rastrear tweens espec√≠ficos de misiones
local originalTweenCreate = TweenService.Create
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local runService = game:GetService("RunService")
local playerPos = player.Character.HumanoidRootPart.Position
local hRP = player.Character.HumanoidRootPart


local rifleStatusParagraph
local activeBodyVelocity = nil
local lastKeyCheck = 0
local keyDetected = false
local failedTargets = {}
local wave1GiftStabilizationTime = 0
local wave1LastGiftCount = 0
local wave1StableGiftCount = false
local colorTargets = {"Really blue", "Lime green", "Really red", "New Yeller"}

local debug = false
local farm = false
local wave = 1
local waveParagraph
local vim = cloneref(Instance.new("VirtualInputManager"))
local wave3EnemyStabilized = false
local enemigosPreviosCount = 0

local doWave1, doWave2, doWave3, doWave4, doWave5

local wavePositions = {
    [1] = {
        [1] = Vector3.new(-2035, 9, -14),  -- Ajusta estas coordenadas a las posiciones reales
    },
    [2] = {
        [1] = Vector3.new(-2325, 19, -12),  -- Ajusta estas coordenadas
        [2] = Vector3.new(-2336, 19, 112),
        ["Really blue"] = Vector3.new(-2381, 24, 76),
        ["Lime green"] = Vector3.new(-2369, 23, -33),
        ["Really red"] = Vector3.new(-2308, 21, 165),
        ["New Yeller"] = Vector3.new(-2381, 13, 259)
    },
    [3] = {
        [1] = Vector3.new(-2549, 19, 107), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-2547, 26, 63),
        [3] = Vector3.new(-2577, 27, -18),
        [4] = Vector3.new(-2647, 43, -15),
        [5] = Vector3.new(-2788, 42, -24),
        [6] = Vector3.new(-2970, 120, -21),
        [7] = Vector3.new(-2960, 130, 18)
    },
    [4] = {
        [1] = Vector3.new(-2965, 124, -23), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-3068, 125, -17),
        [3] = Vector3.new(-3194, 118, -20)
    },
    [5] = {
        [1] = Vector3.new(-3747, 99, -25),
        [2] = Vector3.new(-3862, 100, -20),
        [3] = Vector3.new(-4025, 48, -25),
        [4] = Vector3.new(-4331, 175, -24)
    }
}


local processedGifts = {}

local rifleEquipped = false -- A√±adir esta variable global al inicio del script
local lastEquipAttempt = 0
local equipAttempts = 0
local MAX_EQUIP_ATTEMPTS = 5 -- M√°ximo n√∫mero de intentos

-- A√±adir estas variables al principio del script, junto con las otras variables globales
local firstGiftFound = false -- Indica si ya se encontr√≥ el primer regalo
local lastGiftFound = 0
local noGiftDelay = 8 -- Segundos a esperar sin encontrar regalos antes de considerar que ya no hay m√°s

-- A√±adir estas variables al principio del script
local giftCollection = {} -- Tabla para almacenar los regalos accesibles
local lastNewGift = 0 -- √öltimo momento en que se detect√≥ un regalo nuevo accesible
local collectionPhase = false -- Indica si estamos en fase de recolecci√≥n
local waitingForGifts = 3 -- Segundos a esperar sin nuevos regalos antes de empezar a recogerlos
local maxSafeHeight = 10 -- Altura m√°xima segura para evitar el anti-cheat

-- A√±adir esta variable global al inicio del script
local wave3PositionReached = false -- Indica si ya se lleg√≥ a la posici√≥n final de Wave 3

-- Variables globales adicionales 
local autoShootConnection = nil -- Para almacenar la conexi√≥n del Heartbeat
local targetSearchCooldown = 0.5 -- Buscar objetivos cada 0.5 segundos en lugar de cada frame
local lastTargetSearch = 0

-- A√±adir esta variable global para colores entregados
local deliveredColors = {
    ["Really blue"] = false,
    ["Lime green"] = false,
    ["Really red"] = false,
    ["New Yeller"] = false
}

-- Variables
local currentTarget = nil
local lastShot = 0
local isReloading = false
local targetMarker = nil
local heartbeatConnection = nil -- Variable para almacenar la conexi√≥n

local wavePositions = {
    [1] = {
        [1] = Vector3.new(-2035, 9, -14),  -- Ajusta estas coordenadas a las posiciones reales
    },
    [2] = {
        [1] = Vector3.new(-2325, 19, -12),  -- Ajusta estas coordenadas
        [2] = Vector3.new(-2336, 19, 112),
        ["Really blue"] = Vector3.new(-2381, 24, 76),
        ["Lime green"] = Vector3.new(-2369, 23, -33),
        ["Really red"] = Vector3.new(-2308, 21, 165),
        ["New Yeller"] = Vector3.new(-2381, 13, 259)
    },
    [3] = {
        [1] = Vector3.new(-2549, 19, 107), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-2547, 26, 63),
        [3] = Vector3.new(-2577, 27, -18),
        [4] = Vector3.new(-2647, 43, -15),
        [5] = Vector3.new(-2788, 42, -24),
        [6] = Vector3.new(-2970, 120, -21),
        [7] = Vector3.new(-2960, 130, 18)
    },
    [4] = {
        [1] = Vector3.new(-2965, 124, -23), -- Ajusta estas coordenadas a las posiciones reales
        [2] = Vector3.new(-3068, 125, -17),
        [3] = Vector3.new(-3194, 118, -20)
    },
    [5] = {
        [1] = Vector3.new(-3747, 99, -25),
        [2] = Vector3.new(-3862, 100, -20),
        [3] = Vector3.new(-4025, 48, -25),
        [4] = Vector3.new(-4331, 200, -24)
    }
}


local processedGifts = {}

local rifleEquipped = false -- A√±adir esta variable global al inicio del script
local lastEquipAttempt = 0
local equipAttempts = 0
local MAX_EQUIP_ATTEMPTS = 5 -- M√°ximo n√∫mero de intentos

-- A√±adir estas variables al principio del script, junto con las otras variables globales
local firstGiftFound = false -- Indica si ya se encontr√≥ el primer regalo
local lastGiftFound = 0
local noGiftDelay = 8 -- Segundos a esperar sin encontrar regalos antes de considerar que ya no hay m√°s

-- A√±adir estas variables al principio del script
local giftCollection = {} -- Tabla para almacenar los regalos accesibles
local lastNewGift = 0 -- √öltimo momento en que se detect√≥ un regalo nuevo accesible
local collectionPhase = false -- Indica si estamos en fase de recolecci√≥n
local waitingForGifts = 3 -- Segundos a esperar sin nuevos regalos antes de empezar a recogerlos
local maxSafeHeight = 10 -- Altura m√°xima segura para evitar el anti-cheat

-- A√±adir esta variable global al inicio del script
local wave3PositionReached = false -- Indica si ya se lleg√≥ a la posici√≥n final de Wave 3

-- Variables globales adicionales 
local autoShootConnection = nil -- Para almacenar la conexi√≥n del Heartbeat
local targetSearchCooldown = 0.5 -- Buscar objetivos cada 0.5 segundos en lugar de cada frame
local lastTargetSearch = 0

-- A√±adir esta variable global para colores entregados
local deliveredColors = {
    ["Really blue"] = false,
    ["Lime green"] = false,
    ["Really red"] = false,
    ["New Yeller"] = false
}

-- Variables
local currentTarget = nil
local lastShot = 0
local isReloading = false
local targetMarker = nil
local heartbeatConnection = nil -- Variable para almacenar la conexi√≥n
local waveStartTime = 0
local waveTimeout = 300

local function equipWeapon(weapon)
    local success, result = pcall(function()
        -- Create VirtualInputManager if not already created
        
        local hotbar = game:GetService("Players").LocalPlayer.PlayerGui.BackpackGui.Hotbar
        if not hotbar then
            if debug then
                print("Hotbar no encontrado")
            end
            return false
        end
        
        local slotNames = {"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"}
        local keyMapping = {
            Zero = Enum.KeyCode.Zero,
            One = Enum.KeyCode.One,
            Two = Enum.KeyCode.Two,
            Three = Enum.KeyCode.Three,
            Four = Enum.KeyCode.Four,
            Five = Enum.KeyCode.Five,
            Six = Enum.KeyCode.Six,
            Seven = Enum.KeyCode.Seven,
            Eight = Enum.KeyCode.Eight,
            Nine = Enum.KeyCode.Nine
        }
        
        for i, slotName in ipairs(slotNames) do
            local slot = hotbar:FindFirstChild(slotName)
            if slot and slot:FindFirstChild(weapon) then
                -- Use VirtualInputManager to simulate key press
                pcall(function()
                    -- Send key down event
                    vim:SendKeyEvent(true, keyMapping[slotName], false, game)
                    task.wait(0.1)
                    -- Send key up event
                    vim:SendKeyEvent(false, keyMapping[slotName], false, game)
                end)
                
                return true
            end
        end
        
        if debug then
            print("Arma '" .. weapon .. "' no encontrada en el hotbar")
        end
        return false
    end)
    
    if not success then
        if debug then
            print("Error al equipar arma: " .. tostring(result))
        end
        return false
    end
    
    return result
end

task.spawn(function()
    game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
        if child.Name == 'ErrorPrompt' then
            task.spawn(function()
                TeleportService:Teleport(3978370137, game.Players.LocalPlayer)
            end)
        end
    end)
    
    -- Improved wave timeout check
    while true do
        wait(5) -- Check every 5 seconds
        if farm and waveStartTime > 0 then
            local timeInWave = tick() - waveStartTime
            if timeInWave > waveTimeout then
                if debug then
                    print("‚ö†Ô∏è Wave timeout reached! (" .. math.floor(timeInWave) .. " seconds) Teleporting back to lobby...")
                end
                
                -- Force teleport after timeout
                task.spawn(function()
                    TeleportService:Teleport(3978370137, game.Players.LocalPlayer)
                end)
                break
            elseif debug and timeInWave > (waveTimeout - 60) then
                -- Warning when approaching timeout
                print("‚ö†Ô∏è Wave timeout approaching! " .. math.floor(waveTimeout - timeInWave) .. " seconds remaining")
            end
        end
    end
end)


    
    
    -- Funci√≥n para obtener la posici√≥n de un objeto
    local function getObjectPosition(object)
        if not object then
            return nil
        end
    
        if object:IsA("Model") and object.PrimaryPart then
            return object.PrimaryPart.Position
        elseif object:IsA("BasePart") then
            return object.Position
        else
            for _, child in pairs(object:GetDescendants()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        return nil
    end
    
    local function equipItem(item)
        local args = {
            [1] = "equip",
            [2] = item
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Tools"):InvokeServer(unpack(args))
        
    end
    
    
    
    local function getAllGifts()
        local gifts = {}
        
        -- Verificar que tenemos personaje y posici√≥n
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return gifts -- Devolver lista vac√≠a si no hay personaje
        end
        
        local playerPos = player.Character.HumanoidRootPart.Position
        local minDistance = 500 -- Radio de b√∫squeda
        
        -- M√©todo 1: Buscar directamente en workspace por YearGift
        pcall(function()
            -- Buscar en la ruta m√°s com√∫n de los regalos
            local success, presentModels = pcall(function()
                return workspace.Islands["Anniversary 2023"].AreaInfo.Lobby.Environment.Assets.Presents
            end)
            
            if success and presentModels then
                if debug then
                    print("Buscando regalos en: " .. presentModels:GetFullName() .. " (" .. #presentModels:GetChildren() .. " elementos)")
                end
                
                for _, gift in pairs(presentModels:GetChildren()) do
                    if gift and gift.Name == "YearGift" then
                        local giftPos = getObjectPosition(gift)
                        if giftPos then
                            local distance = (giftPos - playerPos).Magnitude
                            if distance < minDistance then
                                table.insert(gifts, gift)
                                if debug then print("Regalo YearGift encontrado en ruta com√∫n") end
                            end
                        end
                    end
                end
            end
        end)
        
        -- M√©todo 2: Buscar espec√≠ficamente en Effects.PresentModels si existe
        pcall(function()
            if workspace:FindFirstChild("Effects") and workspace.Effects:FindFirstChild("PresentModels") then
                for _, gift in pairs(workspace.Effects.PresentModels:GetChildren()) do
                    if gift and gift.Name == "YearGift" then
                        local giftPos = getObjectPosition(gift)
                        if giftPos then
                            local distance = (giftPos - playerPos).Magnitude
                            if distance < minDistance then
                                local duplicate = false
                                for _, existingGift in ipairs(gifts) do
                                    if existingGift and getObjectPosition(existingGift) and
                                       (getObjectPosition(existingGift) - giftPos).Magnitude < 5 then
                                        duplicate = true
                                        break
                                    end
                                end
                                
                                if not duplicate then
                                    table.insert(gifts, gift)
                                    if debug then
                                        print("Regalo YearGift encontrado en Effects.PresentModels: " .. gift:GetFullName())
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        
        -- M√©todo 3: Buscar YearGift en todo el workspace como √∫ltimo recurso
        -- SOLO busca objetos con el nombre EXACTO "YearGift"
        pcall(function()
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj.Name == "YearGift" then  -- SOLO nombre exacto
                    local giftPos = getObjectPosition(obj)
                    if giftPos then
                        local distance = (giftPos - playerPos).Magnitude
                        if distance < minDistance then
                            -- Verificar si ya est√° en la lista
                            local duplicate = false
                            for _, existingGift in ipairs(gifts) do
                                if existingGift and getObjectPosition(existingGift) and
                                   (getObjectPosition(existingGift) - giftPos).Magnitude < 5 then
                                    duplicate = true
                                    break
                                end
                            end
                            
                            if not duplicate then
                                table.insert(gifts, obj)
                                if debug then
                                    print("Regalo YearGift encontrado en workspace: " .. obj:GetFullName())
                                end
                            end
                        end
                    end
                end
            end
        end)
        
        if debug then
            print("Total de YearGifts encontrados: " .. #gifts)
        end
        
        return gifts
    end
    
    
    
    
    
    --[[
    
    wave 1 function
    
    
    ]]--
    local function setupBodyVelocity()
        -- Limpiar cualquier BodyVelocity existente primero
        if activeBodyVelocity then
            pcall(function() activeBodyVelocity:Destroy() end)
            activeBodyVelocity = nil
        end
        
        -- Verificar que tenemos acceso al personaje y HumanoidRootPart
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Crear nuevo BodyVelocity
            activeBodyVelocity = Instance.new("BodyVelocity")
            activeBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            activeBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            activeBodyVelocity.Parent = player.Character.HumanoidRootPart
        else
            if debug then
                print("Error en setupBodyVelocity: HumanoidRootPart no disponible")
            end
        end
    end
    
    -- Funci√≥n para limpiar el BodyVelocity
    local function clearBodyVelocity()
        if activeBodyVelocity then
            pcall(function() activeBodyVelocity:Destroy() end)
            activeBodyVelocity = nil
        end
    end
    
    local function key()
        -- Solo verificar cada cierto intervalo para no sobrecargar
        if tick() - lastKeyCheck < 1 then
            return keyDetected
        end
        
        -- Actualizar el tiempo de la √∫ltima verificaci√≥n
        lastKeyCheck = tick()
        
        -- Usar pcall para evitar errores si la ruta no existe
        local success, result = pcall(function()
            return workspace.Islands["Anniversary 2023"].AreaInfo.KeyFinder.Environment.Key ~= nil
        end)
        
        -- Si se encontr√≥ la Key y es un MeshPart
        if success and result then
            local keyPart = workspace.Islands["Anniversary 2023"].AreaInfo.KeyFinder.Environment.Key
            
            -- Verificar que sea un MeshPart
            if keyPart and keyPart:IsA("MeshPart") then
                if debugMode then
                    print("üîë KEY DETECTADA: Confirmaci√≥n de Wave 2")
                end
                
                keyDetected = true
                return true
            end
        end
        
        -- No se encontr√≥ la Key
        return false
    end
    
    local function tween(position, disableAutoInteract)
        if not position then 
            if debug then
                print("Error: tween llamado con posici√≥n nula")
            end
            return false 
        end
        
        -- Asegurarse de que tengamos acceso al personaje
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if debug then
                print("Error: HumanoidRootPart no disponible")
            end
            return false
        end
        
        local rootPart = player.Character.HumanoidRootPart
        
        -- Configurar BodyVelocity de forma simple
        pcall(function() 
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
            end
            activeBodyVelocity = Instance.new("BodyVelocity")
            activeBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            activeBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            activeBodyVelocity.Parent = rootPart
        end)
        
        -- Elevar ligeramente para evitar obst√°culos
        rootPart.CFrame = CFrame.new(rootPart.Position.x, rootPart.Position.y + 15, rootPart.Position.z)
        
        
        -- Calcular distancia y tiempo
        local distance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia al objetivo: " .. distance) end
        
        -- M√°xima velocidad
        local velocidad = 60 -- Velocidad moderada para mayor precisi√≥n
        local tweenInfo = TweenInfo.new(
            distance / velocidad,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.Out
        )
        
        -- Ejecutar tween con una flag de completado
        local tweenCompleted = false
        pcall(function()
            local tweenInstance = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(position)})
            
            -- Conectar evento de completado
            tweenInstance.Completed:Connect(function()
                tweenCompleted = true
                if debug then print("Tween completado totalmente") end
            end)
            
            tweenInstance:Play()
            
    
            
            -- Esperar a que termine el tween completamente
            local startTime = tick()
            local timeout = (distance / velocidad) + 1 -- A√±adir 1 segundo de margen
            
            while not tweenCompleted and (tick() - startTime) < timeout do
                wait(0.1)
            end
            
            if not tweenCompleted then
                if debug then print("Tween no se complet√≥ en el tiempo esperado, pero continuamos") end
            end
        end)
        
        -- Solo interactuar si se solicita
        if not disableAutoInteract then
            -- Interactuar una sola vez con el prompt m√°s cercano
            pcall(function()
                local closestPrompt = nil
                local minDistance = 5
                
                for _, prompt in pairs(workspace:GetDescendants()) do
                    if prompt:IsA("ProximityPrompt") and prompt.Enabled then
                        local parent = prompt.Parent
                        if parent and parent:IsA("BasePart") then
                            local promptDistance = (parent.Position - rootPart.Position).Magnitude
                            if promptDistance < minDistance then
                                minDistance = promptDistance
                                closestPrompt = prompt
                            end
                        end
                    end
                end
                
                if closestPrompt then
                        fireproximityprompt(closestPrompt)
    
                    
                    
                    if debug then print("Interactuando con prompt") end
                end
            end)
        end
        
        -- Limpiar BodyVelocity inmediatamente
        pcall(function()
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
                activeBodyVelocity = nil
            end
        end)
        
        -- Verificar la distancia final para determinar si llegamos con precisi√≥n
        local finalDistance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia final al objetivo: " .. finalDistance) end
        
        -- Considerar exitoso si estamos lo suficientemente cerca
        return finalDistance < 5
    end
    
    
    local function tweenwave4(position, disableAutoInteract)
        if not position then 
            if debug then
                print("Error: tween llamado con posici√≥n nula")
            end
            return false 
        end
        
        -- Asegurarse de que tengamos acceso al personaje
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if debug then
                print("Error: HumanoidRootPart no disponible")
            end
            return false
        end
        
        local rootPart = player.Character.HumanoidRootPart
        
        -- Configurar BodyVelocity de forma simple
        pcall(function() 
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
            end
            activeBodyVelocity = Instance.new("BodyVelocity")
            activeBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            activeBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            activeBodyVelocity.Parent = rootPart
        end)
        
        -- Elevar ligeramente para evitar obst√°culos
        rootPart.CFrame = CFrame.new(rootPart.Position.x, rootPart.Position.y + 3, rootPart.Position.z)
        
        -- Calcular distancia y tiempo
        local distance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia al objetivo: " .. distance) end
        
        -- M√°xima velocidad
        local velocidad = 35 -- Velocidad moderada para mayor precisi√≥n
        local tweenInfo = TweenInfo.new(
            distance / velocidad,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.Out
        )
        
        -- Ejecutar tween con una flag de completado
        local tweenCompleted = false
        pcall(function()
            local tweenInstance = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(position)})
            
            -- Conectar evento de completado
            tweenInstance.Completed:Connect(function()
                tweenCompleted = true
                if debug then print("Tween completado totalmente") end
            end)
            
            tweenInstance:Play()
            
            -- Esperar a que termine el tween completamente
            local startTime = tick()
            local timeout = (distance / velocidad) + 1 -- A√±adir 1 segundo de margen
            
            while not tweenCompleted and (tick() - startTime) < timeout do
                wait(0.1)
            end
            
            if not tweenCompleted then
                if debug then print("Tween no se complet√≥ en el tiempo esperado, pero continuamos") end
            end
        end)
        
        -- Solo interactuar si se solicita
        if not disableAutoInteract then
            -- Interactuar una sola vez con el prompt m√°s cercano
            pcall(function()
                local closestPrompt = nil
                local minDistance = 5
                
                for _, prompt in pairs(workspace:GetDescendants()) do
                    if prompt:IsA("ProximityPrompt") and prompt.Enabled then
                        local parent = prompt.Parent
                        if parent and parent:IsA("BasePart") then
                            local promptDistance = (parent.Position - rootPart.Position).Magnitude
                            if promptDistance < minDistance then
                                minDistance = promptDistance
                                closestPrompt = prompt
                            end
                        end
                    end
                end
                
                if closestPrompt then
                    for i = 1, 6 do
                        fireproximityprompt(closestPrompt)
                    end
                    
                    
                    if debug then print("Interactuando con prompt") end
                end
            end)
        end
        
        -- Limpiar BodyVelocity inmediatamente
        pcall(function()
            if activeBodyVelocity then
                activeBodyVelocity:Destroy()
                activeBodyVelocity = nil
            end
        end)
        
        -- Verificar la distancia final para determinar si llegamos con precisi√≥n
        local finalDistance = (position - rootPart.Position).Magnitude
        if debug then print("Distancia final al objetivo: " .. finalDistance) end
        
        -- Considerar exitoso si estamos lo suficientemente cerca
        return finalDistance < 5
    end
    
    local function nearesrGift()
        -- Verificar si el jugador y su personaje est√°n disponibles
        if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if debug then
                print("Error: El personaje o HumanoidRootPart no est√° disponible")
            end
            return {}
        end
        
        -- Posici√≥n del jugador
        local posicionJugador = player.Character.HumanoidRootPart.Position
        
        -- Tabla para almacenar los regalos encontrados
        local regalosCercanos = {}
        
        -- Intentar encontrar los regalos usando pcall para evitar errores
        local exito, errorMensaje = pcall(function()
            -- Verificar que exista la ruta a los regalos
            if workspace.Effects and workspace.Effects.PresentModels then
                -- Buscar todos los regalos del a√±o
                for _, regalo in pairs(workspace.Effects.PresentModels:GetChildren()) do
                    -- Verificar si es un regalo del a√±o
                    if regalo.Name:match("YearGift") then
                        -- Obtener la posici√≥n del regalo
                        local posicionRegalo = getObjectPosition(regalo)
                        
                        if posicionRegalo then
                            -- Calcular la distancia entre el jugador y el regalo
                            local distancia = (posicionRegalo - posicionJugador).Magnitude
                            
                            -- Agregar el regalo a la tabla con su distancia
                            table.insert(regalosCercanos, {
                                regalo = regalo,
                                distancia = distancia,
                                posicion = posicionRegalo
                            })
                            
                            if debug then
                                print("Regalo encontrado a distancia: " .. distancia)
                            end
                        end
                    end
                end
            else
                if debug then
                    print("No se encontr√≥ la ruta workspace.Effects.PresentModels")
                end
            end
        end)
        
        if not exito and debug then
            print("Error al buscar regalos: " .. tostring(errorMensaje))
        end
        
        -- Ordenar los regalos por distancia (m√°s cercanos primero)
        table.sort(regalosCercanos, function(a, b)
            return a.distancia < b.distancia
        end)
        
        return regalosCercanos
    end
    
    
    local function gotoWavePosition(waveNumber, positionNumber)
        -- Verificaciones de seguridad m√°s robustas
        if type(waveNumber) ~= "number" or type(positionNumber) ~= "number" then
            if debug then
                print("Error: N√∫meros de wave o posici√≥n inv√°lidos")
            end
            return false
        end
        
        if not wavePositions[waveNumber] then
            if debug then
                print("Error: Wave " .. waveNumber .. " no tiene posiciones definidas")
            end
            return false
        end
        
        if not wavePositions[waveNumber][positionNumber] then
            if debug then
                print("Error: Posici√≥n " .. positionNumber .. " no definida para Wave " .. waveNumber)
            end
            return false
        end
        
        local targetPosition = wavePositions[waveNumber][positionNumber]
        
        if debug then
            print("Moviendo a posici√≥n " .. positionNumber .. " de Wave " .. waveNumber .. ": " .. tostring(targetPosition))
        end
        
        -- Usar nuestra funci√≥n tween para moverse
        return tween(targetPosition, false)
    end
    
    
    
    
    
    -- Add this variable at the top of your script with the other global variables
    local processedGiftsWave1 = {}
    
    -- Then modify the doWave1 function
    -- Modify the doWave1 function to avoid repeated stabilization waits
    doWave1 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        -- Verificar primero si ha aparecido la key
        if key() then
            wave = 2
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 2!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio autom√°tico",
                Description = "¬°Key detectada! Cambiando a Wave 2",
                Lifetime = 3
            })
        end
    
            wait(1)
            gotoWavePosition(1, 1)
            gotoWavePosition(2, 1)
            return true -- Indicar cambio de wave
        end
    
        -- Buscar regalos cercanos
        local gifts = nearesrGift()
        
        -- NUEVA L√ìGICA: Detectar cuando los regalos se han estabilizado
        if #gifts > 0 then
            -- Si el n√∫mero de regalos ha cambiado significativamente (m√°s de 2 nuevos regalos), reiniciar el temporizador
            -- Solo si a√∫n no hemos comenzado a recoger regalos
            if wave1LastGiftCount > 0 and (#gifts - wave1LastGiftCount) > 2 and #processedGiftsWave1 == 0 then
                if debug then
                    print("N√∫mero de regalos aument√≥ significativamente: " .. wave1LastGiftCount .. " -> " .. #gifts)
                end
                wave1LastGiftCount = #gifts
                wave1GiftStabilizationTime = tick()
                wave1StableGiftCount = false
            -- Si es la primera vez que vemos regalos o hay un cambio normal
            elseif wave1LastGiftCount ~= #gifts and not wave1StableGiftCount then
                if debug then
                    print("N√∫mero de regalos cambi√≥: " .. wave1LastGiftCount .. " -> " .. #gifts)
                end
                wave1LastGiftCount = #gifts
                wave1GiftStabilizationTime = tick()
            -- Si ya estamos en proceso de recolecci√≥n, no reiniciar la estabilizaci√≥n
            elseif not wave1StableGiftCount and #processedGiftsWave1 == 0 then
                -- Si el n√∫mero de regalos no ha cambiado durante 3 segundos, considerarlos estables
                if (tick() - wave1GiftStabilizationTime) > 3 then
                    wave1StableGiftCount = true
                    if debug then
                        print("Regalos estabilizados: " .. #gifts .. " regalos detectados")
                    end
                    if debug then
                        Window:Notify({
                        Title = "Regalos estabilizados",
                        Description = "Comenzando recolecci√≥n de " .. #gifts .. " regalos",
                        Lifetime = 2
                    })
                end
                    -- Reiniciar la lista de regalos procesados para recogerlos todos
                    processedGiftsWave1 = {}
                else
                    if debug then
                        print("Esperando estabilizaci√≥n de regalos: " .. math.floor(tick() - wave1GiftStabilizationTime) .. "/3 segundos")
                    end
                    wait(0.5) -- Esperar mientras se estabilizan
                    return false
                end
            end
        else
            -- Si no hay regalos y no estamos en proceso de recolecci√≥n, reiniciar el estado
            if #processedGiftsWave1 == 0 then
                wave1LastGiftCount = 0
                wave1StableGiftCount = false
            end
            wait(0.5)
            return false
        end
        
        -- Solo proceder a esperar estabilizaci√≥n si no hemos comenzado a recoger regalos
        if not wave1StableGiftCount and #processedGiftsWave1 == 0 then
            wait(0.5)
            return false
        end
    
        -- A partir de aqu√≠, la l√≥gica es similar a la original pero solo se ejecuta cuando los regalos est√°n estabilizados
        -- o ya hemos comenzado a recoger regalos
        local validGift = nil
        
        -- Buscar un regalo que no haya sido procesado a√∫n
        for _, gift in ipairs(gifts) do
            local giftId = tostring(gift.posicion)
            if not processedGiftsWave1[giftId] then
                validGift = gift
                break
            end
        end
    
        if validGift then
            local giftId = tostring(validGift.posicion)
            
            -- Marcar este regalo como procesado antes de moverse a √©l
            processedGiftsWave1[giftId] = true
            
            if debug then
                print("Yendo a regalo en posici√≥n: " .. giftId)
            end
            
            -- Ir al regalo e interactuar
            tween(validGift.posicion, false)
            
            -- Verificar key inmediatamente
            if key() then
                wave = 2
                if waveParagraph then
                    waveParagraph:UpdateBody("Wave 2!")
                end
    
                gotoWavePosition(1, 1)
                gotoWavePosition(2, 1)
                return true -- Cambiar a Wave 2 inmediatamente
            end
            
            -- No wait here - continue to next gift immediately
            return false
        else
            -- Si todos los regalos visibles ya fueron procesados, limpiar la lista
            -- para permitir que se procesen nuevamente en caso de que aparezcan nuevos
            if #gifts > 0 then
                processedGiftsWave1 = {}
                if debug then
                    print("Reiniciando lista de regalos procesados")
                end
            end
            
            -- Si no hay regalos, esperar un tiempo m√≠nimo
            wait(0.05)
            return false
        end
    end
    
    
    --[[
    
    wave 2 function
    
    
    ]]--
    
    local function getGiftColor(gift)
        if not gift or not gift:IsA("Model") then return nil end
        
        -- Usar pcall para evitar errores
        local success, color = pcall(function()
            -- Primer intento: buscar el patr√≥n est√°ndar Bottom -> ColorStrip
            local colorStrip = gift:FindFirstChild("Bottom") and gift.Bottom:FindFirstChild("ColorStrip")
            if colorStrip and colorStrip:IsA("BasePart") then
                return tostring(colorStrip.BrickColor)
            end
            
            -- Segundo intento: buscar ColorStrip en cualquier parte del regalo
            local foundColorStrip = gift:FindFirstDescendant("ColorStrip")
            if foundColorStrip and foundColorStrip:IsA("BasePart") then
                return tostring(foundColorStrip.BrickColor)
            end
            
            -- Tercer intento: buscar cualquier parte con un color que no sea gris
            for _, part in pairs(gift:GetDescendants()) do
                if part:IsA("BasePart") then
                    local partColor = tostring(part.BrickColor)
                    if partColor ~= "Medium stone grey" and partColor ~= "Light stone grey" then
                        return partColor
                    end
                end
            end
            
            return nil
        end)
        
        return success and color or nil
    end
    
    local function normalizeColor(color)
        -- Normalizar nombres de colores
        if typeof(color) ~= "string" then return nil end
        
        -- Convertir a min√∫sculas para comparaci√≥n
        local lowerColor = string.lower(color)
        
        -- Mapear variantes de nombres de colores a los colores est√°ndar
        if string.find(lowerColor, "blue") or string.find(lowerColor, "azul") then
            return "Really blue"
        elseif string.find(lowerColor, "green") or string.find(lowerColor, "verde") then
            return "Lime green"
        elseif string.find(lowerColor, "red") or string.find(lowerColor, "rojo") then
            return "Really red"
        elseif string.find(lowerColor, "yellow") or string.find(lowerColor, "amarillo") or string.find(lowerColor, "yeller") then
            return "New Yeller"
        end
        
        -- Si es un color est√°ndar, devolverlo tal cual
        if color == "Really blue" or color == "Lime green" or color == "Really red" or color == "New Yeller" then
            return color
        end
        
        -- No pudo normalizarse
        return nil
    end
    
    local function isColorDelivered(color)
        if not color then return false end
        
        -- Normalizar el color por si acaso
        local normalizedColor = normalizeColor(color)
        if not normalizedColor then return false end
        
        -- Verificar si el color est√° marcado como entregado
        return deliveredColors[normalizedColor] == true
    end
    
    local function markColorAsDelivered(color)
        -- Normalizar el color
        local normalizedColor = normalizeColor(color)
        if normalizedColor and deliveredColors[normalizedColor] ~= nil then
            deliveredColors[normalizedColor] = true
            if debug then
                print("‚úÖ Color " .. normalizedColor .. " marcado como entregado")
            end
            return true
        end
        return false
    end
    
    -- Funci√≥n para el control de Wave 2
    doWave2 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        if debug then
            print("Ejecutando l√≥gica de Wave 2")
        end
    
        -- Actualizar la posici√≥n del jugador siempre al inicio
        playerPos = player.Character.HumanoidRootPart.Position
        
        -- Verificar si todos los colores han sido entregados
        local todosProcesados = true
        for color, entregado in pairs(deliveredColors) do
            if not entregado then
                todosProcesados = false
                break
            end
        end
        
        if todosProcesados then
            if debug then print("¬°Todos los colores entregados! Pasando a Wave 3") end
            wave = 3
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 3!")
            end
            wait(1)
            return true
        end
    
        -- Ir primero a la posici√≥n base antes de buscar regalos
        if debug then print("Yendo a la posici√≥n base...") end
        gotoWavePosition(2, 2)
    
        local allGifts = getAllGifts()
        if debug then print("Encontrados " .. #allGifts .. " regalos en total") end
    
        local giftsToCollect = {}
        for _, gift in ipairs(allGifts) do
            local giftColor = getGiftColor(gift)
            if giftColor then
                local normalizedColor = normalizeColor(giftColor)
                if normalizedColor and not deliveredColors[normalizedColor] then
                    -- Obtener la posici√≥n del regalo correctamente
                    local giftPosition = getObjectPosition(gift)
                    
                    if giftPosition then -- Solo agregar si tiene posici√≥n v√°lida
                        table.insert(giftsToCollect, {
                            objeto = gift,           -- Guardar el objeto para referencia
                            posicion = giftPosition, -- Guardar la posici√≥n como Vector3
                            color = normalizedColor
                        })
                        if debug then print("Regalo candidato: " .. normalizedColor) end
                    end
                end
            end
        end
    
        local closest = nil
        local minDist = math.huge
        
        for _, gift in ipairs(giftsToCollect) do
            local dist = (playerPos - gift.posicion).Magnitude
            if dist < minDist then
                minDist = dist
                closest = gift
            end
        end
    
        if closest then
            if debug then
                print("Recogiendo regalo " .. closest.color .. " a " .. math.floor(minDist) .. " distancia")
            end
            
            -- Moverse al regalo con varios intentos
            local moveSuccess = false
            
            -- Intento 1: tween normal
            if debug then print("Intento 1: Usando tween normal") end
            pcall(function() 
                moveSuccess = tween(closest.posicion) 
            end)
            
            -- Si fall√≥, probar con teletransporte directo
            if not moveSuccess then
                if debug then print("Intento 2: Usando teletransporte directo") end
                pcall(function()
                    hRP.CFrame = CFrame.new(closest.posicion)
                    moveSuccess = true
                    wait(1) -- Esperar m√°s tiempo para estabilizar
                end)
            end
            
            -- Esperar a recoger el regalo (m√°s tiempo)
            wait(0.5)
            
            -- Entregar el regalo al lugar correcto seg√∫n su color sin volver a la base
            local entregaExitosa = false
            
            -- Mapeo de colores a posiciones de entrega
            local entregaPositions = {
                ["Really blue"] = Vector3.new(-2381, 24, 78),
                ["Lime green"] = Vector3.new(-2369, 23, -33),
                ["Really red"] = Vector3.new(-2307, 21, 169),
                ["New Yeller"] = Vector3.new(-2382, 13, 261)
            }
            
            -- Posici√≥n para el color actual
            local deliveryPos = entregaPositions[closest.color]
            
            if deliveryPos then
                -- NUEVO: Verificar si es Lime green y est√° cerca de la posici√≥n especial
                local specialPosition = Vector3.new(-2506, 19, 107)
                local isNearSpecialPosition = false
                
                if closest.color == "Lime green" then
                    local distanceToSpecial = (closest.posicion - specialPosition).Magnitude
                    if distanceToSpecial <= 60 then
                        isNearSpecialPosition = true
                        if debug then
                            print("Regalo Lime green detectado cerca de posici√≥n especial: " .. math.floor(distanceToSpecial) .. " unidades")
                        end
                    end
                end
                
                -- Si es Lime green cerca de la posici√≥n especial, ir primero a la base
                if isNearSpecialPosition then
                    if debug then
                        print("Caso especial: Lime green cerca de posici√≥n especial, yendo primero a la base")
                    end
                    -- Modificado: Usar tween directamente con interacci√≥n desactivada en lugar de gotoWavePosition
                    local basePosition = wavePositions[2][2]
                    tween(basePosition, true) -- true para deshabilitar la interacci√≥n autom√°tica
                    wait(1)
                end
                if debug then
                    print("Entregando regalo " .. closest.color .. " a posici√≥n espec√≠fica")
                end
    
                
                
                -- Intentos m√∫ltiples para asegurar la entrega
                local maxIntentos = 3
                local intentoActual = 0
                local deliverySuccess = false
                
                while not deliverySuccess and intentoActual < maxIntentos do
                    intentoActual = intentoActual + 1
                    
                    if debug then print("Intento " .. intentoActual .. " de entregar a posici√≥n") end
                    
                    -- Tween a la posici√≥n de entrega y verificar si se lleg√≥ correctamente
                    deliverySuccess = tween(deliveryPos)
                    
                    -- Si el tween reporta √©xito
                    if deliverySuccess then
                        if debug then print("Llegamos a la posici√≥n de entrega exacta") end
                        
                        -- Esperar un momento para que se registre la entrega (m√°s tiempo)
                        
                        -- Marcar como entregado manualmente
                        markColorAsDelivered(closest.color)
                        entregaExitosa = true
                        
                        -- Notificar al usuario
                        if debug then
                            Window:Notify({
                                Title = "Entrega exitosa",
                                Description = "Regalo " .. closest.color .. " entregado",
                                Lifetime = 3
                        })
                    end
                        
                        -- AHORA volver a la posici√≥n base despu√©s de entregar exitosamente un regalo
                        if debug then print("Volviendo a la posici√≥n base despu√©s de entregar...") end
                        gotoWavePosition(2, 2)
                        wait(1)
                        
                        break
                    else
                        if debug then print("Intento fallido, reintentando") end
                        wait(1) -- Esperar un poco antes de reintentar
                    end
                end
                
                -- Si no tuvimos √©xito con los tweens, probar teletransporte directo
                if not deliverySuccess then
                    if debug then print("Intento final: Teletransporte directo a posici√≥n de entrega") end
                    pcall(function()
                        hRP.CFrame = CFrame.new(deliveryPos)-- Esperar m√°s tiempo para que se registre la entrega
                        
                        -- Marcar como entregado manualmente
                        markColorAsDelivered(closest.color)
                        entregaExitosa = true
                        
                        -- Notificar al usuario
                        if debug then
                            Window:Notify({
                            Title = "Entrega con teletransporte",
                            Description = "Regalo " .. closest.color .. " entregado",
                            Lifetime = 3
                        })
                    end
                        
                        -- AHORA volver a la posici√≥n base despu√©s de entregar exitosamente un regalo
                        if debug then print("Volviendo a la posici√≥n base despu√©s de entregar...") end
                        gotoWavePosition(2, 2)
                        wait(1)
                    end)
                end
            else
                if debug then print("Error: No hay posici√≥n de entrega definida para " .. closest.color) end
                -- Volver a la posici√≥n base si no hay posici√≥n de entrega
                if debug then print("Volviendo a la posici√≥n base...") end
                gotoWavePosition(2, 2)
                wait(1)
            end
            
            -- Si la entrega fall√≥ despu√©s de todos los intentos
            if not entregaExitosa then
                if debug then print("‚ö†Ô∏è No se pudo entregar el regalo " .. closest.color .. " despu√©s de m√∫ltiples intentos") end
                
                -- Volver a la posici√≥n base incluso si fall√≥ la entrega
                if debug then print("Volviendo a la posici√≥n base...") end
                gotoWavePosition(2, 2)
                wait(1)
            end
        else
            if debug then print("No se encontr√≥ ning√∫n regalo cercano") end
            wait(1)
        end
    
        wait(0.5) -- Reducir espera entre ciclos
        return false -- Seguir en Wave 2
    end
    
    
    
    --[[
    
    wave 3 
    
    
    ]]--
    
    local wave3 = false
    local wave3EnemyStabilized = false
    local enemigosPreviosCount = 0
    
    -- Variables locales para las posiciones estrat√©gicas
    local posicionInicial = wavePositions[3][1]
    local posicionPrimaria = Vector3.new(-2680, 80, -126)
    local posicionIntermedia = Vector3.new(-2742, 39, -32)
    local posicionFinal = Vector3.new(-2551, 96, -73) 
    
    -- Estado de la secuencia (a√±adir esta variable global al inicio del script)
    local wave3SequenceState = nil
    
    -- Variables para detecci√≥n de ausencia de OPEN ME
    local lastEnemyDetectedTime = nil
    
    -- Funci√≥n para obtener instancias nil
    function getNil(name, class)
        -- Verificar primero si la funci√≥n getnilinstances existe
        if not getnilinstances then
            if debug then
                print("La funci√≥n getnilinstances no est√° disponible")
            end
            return nil
        end
        
        -- Envolver en pcall para evitar errores
        local success, instances = pcall(function()
            return getnilinstances()
        end)
        
        if not success or not instances then
            if debug then
                print("Error al obtener nil instances: " .. tostring(instances))
            end
            return nil
        end
        
        -- Buscar la instancia solicitada
        for _, v in pairs(instances) do
            if v and v.ClassName == class and v.Name == name then
                return v
            end
        end
        return nil -- Devolver nil expl√≠citamente si no se encuentra
    end
    
    -- Configuraci√≥n
    local config = {
        enabled = true, -- Siempre activado desde el inicio
        range = math.huge, -- Distancia infinita para atacar
        autoReload = true,
        checkRaycast = true, -- Desactivado para permitir disparar a trav√©s de obst√°culos
        targetPart = "HumanoidRootPart", -- Parte del NPC a la que disparar
        visualizeTarget = false -- Crear un marcador visual para el objetivo
    }
    
    -- Crear marcador visual
    local function createTargetMarker()
        if targetMarker then return end
        
        targetMarker = Instance.new("Part")
        targetMarker.Anchored = true
        targetMarker.CanCollide = false
        targetMarker.Size = Vector3.new(0.5, 0.5, 0.5)
        targetMarker.Color = Color3.fromRGB(255, 0, 0)
        targetMarker.Material = Enum.Material.Neon
        targetMarker.Shape = Enum.PartType.Ball
        targetMarker.Transparency = 0.5
        targetMarker.Parent = workspace
    end
    
    -- Encontrar el bandido m√°s cercano
    local function findOPENME()
        -- Usar pcall para todo el proceso
        local success, result = pcall(function()
            local closestDistance = config.range
            local closest = nil
            
            -- Verificar si workspace y NPCs existen
            if not workspace or not workspace:FindFirstChild("NPCs") then
                if debug then
                    print("workspace.NPCs no encontrado")
                end
                return nil
            end
            
            -- Limpiar objetivos fallidos antiguos (m√°s de 10 segundos)
            local currentTime = tick()
            for targetId, failInfo in pairs(failedTargets) do
                -- Si han pasado m√°s de 30 segundos o el objetivo ha recibido menos de 5 intentos
                if currentTime - failInfo.time > 30 or failInfo.attempts < 5 then
                    failedTargets[targetId] = nil
                
                -- Si el objetivo ha recibido m√°s de 10 intentos, marcarlo como raycastOnly en lugar de eliminarlo
                elseif failInfo.attempts > 10 and not failInfo.raycastOnly then
                    -- Marcar como raycastOnly en lugar de eliminar
                    if debug then
                        print("Objetivo marcado como raycastOnly despu√©s de demasiados intentos: " .. targetId)
                    end
                    failedTargets[targetId].raycastOnly = true
                end
            end
    
            local specialPosition = Vector3.new(-2649, 38, -11)
            local specialRadius = 68
            
            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                    local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            -- Verificar si est√° en el radio especial
                            local distanceToSpecial = (targetPart.Position - specialPosition).Magnitude
                            if distanceToSpecial <= specialRadius then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                if distance < closestDistance then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                    if debug then
                                        print("Enemigo en zona especial encontrado a distancia: " .. distance)
                                    end
                                end
                            end
                        end
                    end
                end
            end
    
            -- Si no encontramos enemigos en la zona especial, continuar con la l√≥gica normal
            if not closest then
                -- Primero buscar objetivos sin raycast y que no est√©n en la lista de fallidos
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                        local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                
                                -- Verificar si este objetivo est√° en la lista de fallidos
                                local targetId = tostring(npc:GetFullName())
                                local isFailed = failedTargets[targetId] ~= nil
                                local isRaycastOnly = isFailed and failedTargets[targetId].raycastOnly == true
                                
                                -- Comprobar si hay obst√°culos mediante raycast
                                local canSee = true
                                local ray = Ray.new(player.Character.HumanoidRootPart.Position, targetPart.Position - player.Character.HumanoidRootPart.Position)
                                local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                canSee = hit == nil
                                
                                -- Priorizar objetivos sin raycast y que no est√©n marcados como raycastOnly
                                if distance < closestDistance and canSee and not isRaycastOnly then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                end
                            end
                        end
                    end
                end
            end
    
            if not closest and wave3State == "posicion_primaria" then
                closestDistance = config.range
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                        local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                
                                -- Verificar si este objetivo est√° marcado como raycastOnly
                                local targetId = tostring(npc:GetFullName())
                                local isRaycastOnly = failedTargets[targetId] and failedTargets[targetId].raycastOnly == true
                                
                                if distance < closestDistance and isRaycastOnly then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                end
                            end
                        end
                    end
                end
            end
            
            -- Si a√∫n no encontramos ning√∫n objetivo, buscar cualquier objetivo (incluso con raycast)
            if not closest and config.checkRaycast == false then
                closestDistance = config.range
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                        local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local distance = (player.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                                
                                if distance < closestDistance then
                                    closestDistance = distance
                                    closest = {npc = npc, part = targetPart, distance = distance}
                                end
                            end
                        end
                    end
                end
            end
            
            return closest
        end)
        
        if not success then
            if debug then
                print("Error en findOPENME: " .. tostring(result))
            end
            return nil
        end
        
        return result
    end
    
    -- Recargar rifle
    local function reloadRifle()
        if isReloading then return end
        isReloading = true
        
        local args = {
            [1] = "reload",
            [2] = {
                ["Gun"] = "Rifle"
            }
        }
        
        local success = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("Events")
                :WaitForChild("CIcklcon"):WaitForChild("gunFunctions"):InvokeServer(unpack(args))
        end)
        
        isReloading = false
        return success
    end
    
    -- Disparar al objetivo
    local function shootTarget(target)
        if not target or not target.part then
            if debug then
                print("Target inv√°lido para disparar")
            end
            return false
        end
        
        -- Verificar cooldown
        if tick() - lastShot < 0.5 then return false end
        lastShot = tick()
        
        -- Verificar que el personaje tenga el rifle
        if not player.Character or not player.Character:FindFirstChild("RifleGun") then
            if debug then
                print("RifleGun no encontrado en el personaje")
            end
            return false
        end
        
        -- Crear un ID √∫nico para el objetivo basado en su posici√≥n
        local targetId = "OPEN_ME_" .. tostring(math.floor(target.part.Position.X)) .. "_" .. 
                        tostring(math.floor(target.part.Position.Y)) .. "_" .. 
                        tostring(math.floor(target.part.Position.Z))
        
        -- Hacer que el personaje mire hacia el objetivo
        pcall(function()
            local targetPosition = target.part.Position
            local characterPosition = player.Character.HumanoidRootPart.Position
            local lookVector = (targetPosition - characterPosition).Unit
            local rightVector = Vector3.new(0, 1, 0):Cross(lookVector).Unit
            local upVector = lookVector:Cross(rightVector)
            local currentCFrame = player.Character.HumanoidRootPart.CFrame
            local newCFrame = CFrame.new(
                currentCFrame.Position,
                currentCFrame.Position + lookVector
            )
            player.Character.HumanoidRootPart.CFrame = newCFrame
        end)
        
        -- Disparar con manejo de errores
        local shootSuccess = pcall(function()
            -- Disparar
            local args1 = {
                [1] = "fire",
                [2] = {
                    ["Start"] = player.Character.RifleGun.Hole.CFrame,
                    ["Gun"] = "Rifle",
                    ["joe"] = "true",
                    ["Position"] = target.part.Position
                }
            }
            
            -- Usar pcall para evitar errores
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("CIcklcon"):FireServer(unpack(args1))
            end)
            
            -- Generar evento de da√±o - FIX para el error de FireServer
            local guncastRemote = getNil("guncast", "RemoteEvent")
            if guncastRemote then
                local args2 = {
                    [1] = target.part.Position,
                    [2] = target.part,
                    [3] = 0.1
                }
                
                pcall(function()
                    guncastRemote:FireServer(unpack(args2))
                end)
            else
                if debug then
                    print("RemoteEvent 'guncast' no encontrado")
                end
            end
        end)
        
        -- Verificar si el objetivo sigue vivo despu√©s de disparar
        local targetStillAlive = false
        pcall(function()
            if target.npc and target.npc:FindFirstChild("Humanoid") and target.npc.Humanoid.Health > 0 then
                targetStillAlive = true
            end
        end)
        
        -- Si el objetivo sigue vivo, marcarlo como fallido
        if targetStillAlive then
            -- Inicializar la tabla failedTargets si no existe
            if failedTargets == nil then
                failedTargets = {}
            end
            
            -- Actualizar o crear el registro de intentos
            if not failedTargets[targetId] then
                failedTargets[targetId] = {
                    time = tick(),
                    attempts = 1,
                    raycastOnly = false,
                    position = target.part.Position
                }
                if debug then
                    print("Nuevo objetivo fallido registrado: " .. targetId)
                end
            else
                -- CORREGIDO: Incrementar expl√≠citamente el contador de intentos
                failedTargets[targetId].time = tick()
                failedTargets[targetId].attempts = (failedTargets[targetId].attempts or 0) + 1
                
                -- Marcar como raycastOnly despu√©s de 3 intentos
                if failedTargets[targetId].attempts >= 3 and not failedTargets[targetId].raycastOnly then
                    -- Marcar expl√≠citamente como raycastOnly
                    failedTargets[targetId].raycastOnly = true
                    
                    if debug then
                        print("‚ö†Ô∏è Objetivo marcado como raycastOnly despu√©s de " .. failedTargets[targetId].attempts .. " disparos: " .. targetId)
                        Window:Notify({
                            Title = "Objetivo problem√°tico",
                            Description = "Marcando enemigo como raycastOnly despu√©s de m√∫ltiples intentos",
                            Lifetime = 3
                        })
                    end
                    
                    -- Cambiar de posici√≥n para intentar desde otro √°ngulo
                    if wave3State == "posicion_base" then
                        if debug then print("Cambiando a posici√≥n intermedia1 para objetivos raycast") end
                        wave3State = "posicion_intermedia1"
                        pcall(function() tween(posicionIntermedia1) end)
                    elseif wave3State == "posicion_primaria" then
                        if debug then print("Cambiando a posici√≥n intermedia2 para objetivos raycast") end
                        wave3State = "regreso_intermedia2"
                        pcall(function() tween(posicionIntermedia2) end)
                    end
                end
            end
            
            if debug then
                print("Objetivo no eliminado, marcado como fallido: " .. targetId .. " (Intento " .. tostring(failedTargets[targetId].attempts) .. ")")
            end
        else
            -- Si el objetivo fue eliminado, eliminarlo de la lista de fallidos
            if failedTargets[targetId] then
                failedTargets[targetId] = nil
                if debug then
                    print("‚úÖ Objetivo eliminado correctamente, removido de la lista de fallidos: " .. targetId)
                end
            end
        end
        
        if not shootSuccess and debug then
            print("Error al disparar")
        end
        
        return shootSuccess
    end
    
    -- Bucle principal
    local function mainLoop()
        -- Desconectar cualquier conexi√≥n anterior
        if heartbeatConnection then
            pcall(function()
                heartbeatConnection:Disconnect()
            end)
            heartbeatConnection = nil
        end
        
        if config.visualizeTarget then
            pcall(function()
                createTargetMarker()
            end)
        end
        
        -- Crear nueva conexi√≥n
        local success, connection = pcall(function()
            return runService.Heartbeat:Connect(function()
                -- Verificar si el farming est√° desactivado
                if not farm or not config.enabled then
                    if heartbeatConnection then
                        pcall(function()
                            heartbeatConnection:Disconnect()
                        end)
                        heartbeatConnection = nil
                    end
                    return
                end
                
                -- Envolver todo en pcall para capturar errores sin romper el script
                local success, errorMsg = pcall(function()
                    -- Verificar si tenemos el rifle equipado
                    local character = player.Character
                    if not character or not character:FindFirstChild("RifleGun") then
                        return
                    end
                    
                    -- Encontrar objetivo
                    currentTarget = findOPENME()
                    
                    -- Actualizar marcador visual
                    if targetMarker and currentTarget then
                        pcall(function()
                            targetMarker.Position = currentTarget.part.Position
                            targetMarker.Transparency = 0.5
                        end)
                    elseif targetMarker then
                        pcall(function()
                            targetMarker.Transparency = 1
                        end)
                    end
                    
                    -- Disparar si tenemos objetivo
                    if currentTarget then
                        local success = shootTarget(currentTarget)
                        if not success and config.autoReload then
                            reloadRifle()
                        end
                    end
                end)
                
                -- Manejar errores dentro del Heartbeat
                if not success and debug then
                    print("Error en mainLoop: " .. tostring(errorMsg))
                    Window:Notify({
                        Title = "ERRRRROR",
                        Description = "OwO: " .. tostring(errorMsg),
                        Lifetime = 3
                    })
                end
            end)
        end)
        
        if success and connection then
            heartbeatConnection = connection
            if debug then
                print("Conexi√≥n Heartbeat establecida correctamente")
            end
        else
            if debug then
                print("Error al crear la conexi√≥n Heartbeat: " .. tostring(connection))
                if debug then
                    Window:Notify({
                    Title = "Error en Wave 3",
                    Description = "No se pudo establecer la conexi√≥n. El script continuar√° pero podr√≠a haber problemas.",
                    Lifetime = 5
                })
            end
            end
        end
    end
    
    
    
    
    
    
    
    -- Funci√≥n para el control de Wave 3
    -- Funci√≥n para el control de Wave 3
    doWave3 = function()
        waveStartTime = tick()
        if not farm then
            -- Desconectar Heartbeat al salir
            if heartbeatConnection then
                pcall(function()
                    heartbeatConnection:Disconnect()
                end)
                heartbeatConnection = nil
            end
            return false 
        end
        
        if debug then
            print("Ejecutando l√≥gica de Wave 3")
        end
    
        -- Variables para las posiciones estrat√©gicas
        local posicionBase = wavePositions[3][7] -- Posici√≥n base para disparar
        
        -- Actualizaci√≥n de las coordenadas seg√∫n el nuevo recorrido
        local posicionIntermedia1 = Vector3.new(-2859, 66, -23)
        local posicionIntermedia2 = Vector3.new(-2727, 38, -67)
        local posicionPrimaria = Vector3.new(-2680, 80, -126)
        
        -- Estado de la secuencia
        if wave3State == nil then
            wave3State = "inicio"
        end
        
        -- CORRECCI√ìN: Asegurarse de que lastEnemyDetectedTime est√© inicializado correctamente
        if lastEnemyDetectedTime == nil then
            lastEnemyDetectedTime = tick()
            if debug then
                print("Inicializando lastEnemyDetectedTime: " .. lastEnemyDetectedTime)
            end
        end
        
        -- Usar pcall para manejar errores en la configuraci√≥n inicial
        local success, errorMsg = pcall(function()
            if not wave3 then
                -- Equipar rifle
                local equipSuccess = equipWeapon("Rifle")
                if not equipSuccess and debug then
                    print("No se pudo equipar el rifle, continuando de todos modos")
                end
                
                -- Posicionar inicialmente en la posici√≥n base 3,4
                pcall(function() 
                    if debug then print("Posicionando en la posici√≥n base 3,4") end
                    gotoWavePosition(3, 1)
                    gotoWavePosition(3, 2)
                    gotoWavePosition(3, 3)
                    gotoWavePosition(3, 4) 
                    gotoWavePosition(3, 5)
                    gotoWavePosition(3, 6)
                    gotoWavePosition(3, 7) 
                end)
                
                wave3 = true
                    wave3State = "posicion_base"
                    lastEnemyDetectedTime = tick() -- Reiniciar el contador al iniciar Wave 3
                    if debug then
                        print("Wave 3 iniciada, lastEnemyDetectedTime: " .. lastEnemyDetectedTime)
                    end
                end
    
            if wave3 then
                -- Funci√≥n para detectar enemigos sin raycast (visibles directamente)
                local function hayEnemigosSinRaycast()
                    local resultado = false
                    
                    pcall(function()
                        if workspace and workspace:FindFirstChild("NPCs") then
                            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                    local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                                    if targetPart then
                                        -- Comprobar si hay obst√°culos mediante raycast
                                        local ray = Ray.new(player.Character.HumanoidRootPart.Position, targetPart.Position - player.Character.HumanoidRootPart.Position)
                                        local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                        
                                        -- Si NO hay obst√°culos (hit es nil), entonces hay enemigos sin raycast
                                        if hit == nil then
                                            resultado = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    
                    return resultado
                end
                
                -- Funci√≥n para detectar enemigos con raycast (detr√°s de obst√°culos)
                local function hayEnemigosConRaycast()
                    local resultado = false
                    
                    pcall(function()
                        if workspace and workspace:FindFirstChild("NPCs") then
                            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                    local targetPart = npc:FindFirstChild(config.targetPart) or npc:FindFirstChild("UpperTorso") or npc:FindFirstChild("HumanoidRootPart")
                                    if targetPart then
                                        -- Comprobar si hay obst√°culos mediante raycast
                                        local ray = Ray.new(player.Character.HumanoidRootPart.Position, targetPart.Position - player.Character.HumanoidRootPart.Position)
                                        local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                        
                                        -- Si hay obst√°culos (hit no es nil), entonces hay enemigos con raycast
                                        if hit ~= nil then
                                            resultado = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    
                    return resultado
                end
                
                -- Verificar si hay enemigos visibles (cualquier tipo)
                local hayEnemigos = false
                    pcall(function()
                        if workspace and workspace:FindFirstChild("NPCs") then
                            for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                    hayEnemigos = true
                                    -- CORRECCI√ìN: Actualizar tiempo de √∫ltimo enemigo detectado
                                    lastEnemyDetectedTime = tick()
                                    if debug then
                                        print("OPEN ME detectado, actualizando lastEnemyDetectedTime: " .. lastEnemyDetectedTime)
                                    end
                                    break
                                end
                            end
                        end
                    end)
                
                -- CORRECCI√ìN: Verificar si han pasado 10 segundos sin enemigos para cambiar a Wave 4
                local tiempoSinEnemigos = tick() - lastEnemyDetectedTime
                
                -- Mostrar tiempo sin enemigos en debug
                if debug and not hayEnemigos then
                    print("Tiempo sin enemigos OPEN ME: " .. math.floor(tiempoSinEnemigos) .. "/10 segundos")
                end
    
                -- CORRECCI√ìN: Solo verificar el cambio a Wave 4 si no hay enemigos
                if not hayEnemigos then
                    -- Si han pasado 10 segundos sin enemigos, cambiar a Wave 4
                    if tiempoSinEnemigos >= 10 then
                        -- Verificar una vez m√°s que realmente no hay enemigos (doble verificaci√≥n)
                        local verificacionFinal = false
                        pcall(function()
                            if workspace and workspace:FindFirstChild("NPCs") then
                                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                        verificacionFinal = true
                                        break
                                    end
                                end
                            end
                        end)
                        
                        if not verificacionFinal then
                            if debug then 
                                print("No se han detectado OPEN ME durante 10 segundos continuos. Cambiando a Wave 4...")
                            end
                            
                            if debug then
                                Window:Notify({
                                Title = "Cambio de Wave",
                                Description = "No se detectaron OPEN ME por 10 segundos. Pasando a Wave 4",
                                Lifetime = 5
                            })
                        end
                            
                            -- Desactivar el heartbeat para que no siga disparando durante la transici√≥n
                            if heartbeatConnection then
                                pcall(function()
                                    heartbeatConnection:Disconnect()
                                end)
                                heartbeatConnection = nil
                            end
                            
                            -- Cambiar a Wave 4
                            wave = 4
                            if waveParagraph then
                                waveParagraph:UpdateBody("Wave 4!")
                            end
                            
                            -- Secuencia de movimiento a Wave 4
                            wait(10)
                            pcall(function() gotoWavePosition(4, 1) end)
                            pcall(function() gotoWavePosition(4, 2) end)
                            pcall(function() gotoWavePosition(4, 3) end)
                            wait(1)
                            
                            -- Reiniciar variables de Wave 3
                            wave3 = false
                            wave3State = nil
                            lastEnemyDetectedTime = nil
                            wave3EnemyStabilized = false
                            enemigosPreviosCount = 0
                            
                            return true -- Indicar cambio de wave
                        else
                            -- Si la verificaci√≥n final encontr√≥ enemigos, reiniciar el contador
                            if debug then
                                print("Verificaci√≥n final encontr√≥ enemigos. Reiniciando contador.")
                            end
                            lastEnemyDetectedTime = tick()
                        end
                    end
                else
                    -- CORRECCI√ìN: Si hay enemigos, actualizar el tiempo de √∫ltimo enemigo detectado
                    lastEnemyDetectedTime = tick()
                    if debug then
                        print("Hay enemigos OPEN ME, reiniciando contador")
                    end
                end
                
                -- NUEVA L√ìGICA: Manejar estados seg√∫n los tipos de enemigos
                
                -- Si estamos en la posici√≥n base
                if wave3State == "posicion_base" or wave3State == "inicio" then
                    -- Verificar si estamos en la posici√≥n base, si no, volver a ella
                    local currentPosition = player.Character.HumanoidRootPart.Position
                    local baseDistance = (posicionBase - currentPosition).Magnitude
                    if baseDistance > 10 then
                        if debug then print("Volviendo a posici√≥n base 3,7 para disparar") end
                        pcall(function() tween(posicionBase) end)
                    else
    
                        -- Ya estamos en la posici√≥n base, verificar tipos de enemigos
                        
                        -- NUEVO: Verificar si siguen apareciendo enemigos
                        local enemigosPrevios = 0
                        local enemigosActuales = 0
                        
                        -- Contar enemigos actuales
                        pcall(function()
                            if workspace and workspace:FindFirstChild("NPCs") then
                                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                                    if npc and npc.Name == "OPEN ME" and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                                        enemigosActuales = enemigosActuales + 1
                                    end
                                end
                            end
                        end)
    
                        if not wave3EnemyStabilized then
                            -- Initialize enemigosPreviosCount if it's nil
                            if enemigosPreviosCount == nil then
                                enemigosPreviosCount = 0
                            end
                            
                            if enemigosActuales > enemigosPreviosCount then
                                -- Siguen apareciendo enemigos, actualizar contador y esperar
                                enemigosPreviosCount = enemigosActuales
                                if debug then print("Esperando a que dejen de aparecer OPEN ME. Actuales: " .. enemigosActuales) end
                                config.enabled = false -- Desactivar disparos mientras esperamos
                            else
                                -- El n√∫mero de enemigos se ha estabilizado o reducido
                                if debug then print("OPEN ME estabilizados. Comenzando a disparar.") end
                                wave3EnemyStabilized = true
                                config.enabled = true -- Activar disparos
                            end
                        end
                        -- Ya estamos en la posici√≥n base, verificar tipos de enemigos
                        if wave3EnemyStabilized and hayEnemigosSinRaycast() then
                            -- Si hay enemigos sin raycast y ya se estabilizaron, quedarse en posici√≥n base y disparar
                            if debug then print("Disparando desde posici√≥n base a enemigos sin raycast") end
                        elseif wave3EnemyStabilized and hayEnemigosConRaycast() then
                            -- SOLO si no hay enemigos sin raycast pero S√ç hay con raycast, ir a posici√≥n primaria
                            -- con pasos intermedios para evitar detecci√≥n de anti-cheat
                            if debug then print("Solo quedan enemigos con raycast. Cambiando a posici√≥n primaria con pasos intermedios") end
                            wave3State = "posicion_intermedia1"
                            pcall(function() tween(posicionIntermedia1) end)
                        end
                    end
                -- Si estamos en la primera posici√≥n intermedia
                elseif wave3State == "posicion_intermedia1" then
                    if debug then print("Moviendo a posici√≥n intermedia 2") end
                    wave3State = "posicion_intermedia2"
                    pcall(function() tween(posicionIntermedia2) end)
                -- Si estamos en la segunda posici√≥n intermedia
                elseif wave3State == "posicion_intermedia2" then
                    if debug then print("Moviendo a posici√≥n primaria final") end
                    wave3State = "posicion_primaria"
                    pcall(function() tween(posicionPrimaria) end)
                -- Si estamos en la posici√≥n primaria
            elseif wave3State == "posicion_primaria" then
                -- Si hay enemigos sin raycast, volver a posici√≥n base usando el mismo recorrido inverso
                if hayEnemigosSinRaycast() then
                    if debug then print("Hay enemigos sin raycast, iniciando regreso a posici√≥n base") end
                    wave3State = "regreso_intermedia2"
                    pcall(function() 
                        local tweenSuccess = tween(posicionIntermedia2)
                        if not tweenSuccess and debug then
                            print("Tween a posicionIntermedia2 fall√≥, intentando teleport directo")
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionIntermedia2)
                        end
                    end)
                -- Si no hay enemigos, volver a posici√≥n base
                elseif not hayEnemigos then
                    if debug then print("No hay m√°s enemigos, iniciando regreso a posici√≥n base") end
                    wave3State = "regreso_intermedia2"
                    pcall(function() 
                        local tweenSuccess = tween(posicionIntermedia2)
                        if not tweenSuccess and debug then
                            print("Tween a posicionIntermedia2 fall√≥, intentando teleport directo")
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionIntermedia2)
                        end
                    end)
                else
                    -- Disparar desde posici√≥n actual
                    if debug then print("Disparando desde posici√≥n primaria") end
                end
                -- NUEVO: Estados para el recorrido inverso
            elseif wave3State == "regreso_intermedia2" then
                if debug then print("Regresando a posici√≥n intermedia 1") end
                wave3State = "regreso_intermedia1"
                pcall(function() 
                    local tweenSuccess = tween(posicionIntermedia1)
                    if not tweenSuccess and debug then
                        print("Tween a posicionIntermedia1 fall√≥, intentando teleport directo")
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionIntermedia1)
                    end
                    -- Esperar a que el tween termine
                    wait(1)
                end)
            elseif wave3State == "regreso_intermedia1" then
                if debug then print("Regresando a posici√≥n base") end
                wave3State = "posicion_base"
                pcall(function() 
                    local tweenSuccess = tween(posicionBase)
                    if not tweenSuccess and debug then
                        print("Tween a posicionBase fall√≥, intentando teleport directo")
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(posicionBase)
                    end
                    -- Esperar a que el tween termine
                    wait(1)
                end)
                end
                
                -- Activar el farming para disparar
                if farm then
                    config.enabled = true
                    if not heartbeatConnection then
                        mainLoop()
                    end
                else
                    config.enabled = false
                    -- Desconectar Heartbeat cuando farm es falso
                    if heartbeatConnection then
                        pcall(function()
                            heartbeatConnection:Disconnect()
                        end)
                        heartbeatConnection = nil
                    end
                end
            end
        end)
        
        -- Manejar errores en la configuraci√≥n de Wave 3
        if not success then
            if debug then
                print("Error en configuraci√≥n de Wave 3: " .. tostring(errorMsg))
                if debug then               
                    Window:Notify({
                    Title = "Error recuperable",
                    Description = "Error en Wave 3: " .. tostring(errorMsg) .. ". El script continuar√°.",
                    Lifetime = 3
                })
            end
            end
            wait(2)
        end
        
        wait(1)
        return false -- Seguir en Wave 3
    end
    
    
    --[[
    
    
    wave 4
    
    
    ]]--
    
    -- Funci√≥n para el control de Wave 4
    -- Modify the doWave4 function
    doWave4 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        if debug then
            print("Ejecutando l√≥gica de Wave 4")
        end
        
        -- Verificar si estamos en la posici√≥n correcta para Wave 4
        local currentPosition = player.Character.HumanoidRootPart.Position
        local targetPosition = wavePositions[4][3] -- Posici√≥n final de Wave 4
        local distanceToTarget = (currentPosition - targetPosition).Magnitude
        
        -- Si no estamos en la posici√≥n correcta, ir a ella primero
        if distanceToTarget > 10 then
            if debug then print("Yendo a la posici√≥n final de Wave 4...") end
            gotoWavePosition(4, 3)
            wait(1)
        end
        
        -- Buscar regalos cercanos
        local allGifts = getAllGifts()
        if debug then print("Wave 4: Encontrados " .. #allGifts .. " regalos en total") end
        
        -- Si no hay regalos, esperar un poco y verificar si debemos pasar a Wave 5
        if #allGifts == 0 then
            wave = 5
            if debug then print("No se encontraron regalos en Wave 4, esperando...") end
            wait(1)
            
            -- Verificar si debemos pasar a Wave 5 (puedes ajustar esta l√≥gica)
            local shouldMoveToWave5 = false
            
            -- Ejemplo: verificar si estamos en una posici√≥n espec√≠fica que indica el final de Wave 4
            local finalPosition = Vector3.new(-3158, 120, -16) -- Ajusta esta posici√≥n
            local distanceToFinal = (currentPosition - finalPosition).Magnitude
            
            if distanceToFinal < 10 then
                -- Si estamos cerca de la posici√≥n final y no hay regalos, considerar pasar a Wave 5
                shouldMoveToWave5 = true
            end
            
            if shouldMoveToWave5 then
                if debug then print("Pasando a Wave 5...") end
                wave = 5
                if waveParagraph then
                    waveParagraph:UpdateBody("Wave 5!")
                end
                
                -- Ir a la primera posici√≥n de Wave 5
                gotoWavePosition(5, 1)
                wait(1)
                
                return true -- Indicar cambio de wave
            end
            
            return false -- Seguir en Wave 4
        end
        
        -- Procesar los regalos encontrados
        local closestGift = nil
        local minDistance = math.huge
        
        for _, gift in ipairs(allGifts) do
            -- Obtener la posici√≥n del regalo
            local giftPosition = getObjectPosition(gift)
            
            if giftPosition then
                local distance = (currentPosition - giftPosition).Magnitude
                
                -- Verificar si este regalo ya fue procesado
                local giftId = tostring(giftPosition)
                if not processedGifts[giftId] and distance < minDistance then
                    minDistance = distance
                    closestGift = {
                        objeto = gift,
                        posicion = giftPosition
                    }
                end
            end
        end
        
        -- Si encontramos un regalo no procesado, ir a recogerlo
        if closestGift then
            if debug then
                print("Wave 4: Recogiendo regalo a " .. math.floor(minDistance) .. " distancia")
            end
            
            -- Marcar este regalo como procesado
            local giftId = tostring(closestGift.posicion)
            processedGifts[giftId] = true
            
            -- Moverse al regalo e interactuar
            local moveSuccess = tweenwave4(closestGift.posicion)
            
            -- Si el tween fall√≥, intentar teletransporte directo
            if not moveSuccess then
                if debug then print("Tween fall√≥, usando teletransporte directo") end
                pcall(function()
                    hRP.CFrame = CFrame.new(closestGift.posicion)
                    wait(0.5)
                end)
            end
            
            -- Esperar un momento para que se recoja el regalo
            wait(1)
            
            -- Notificar al usuario
            if debug then
                Window:Notify({
                Title = "Regalo recogido",
                Description = "Regalo de Wave 4 recogido con √©xito",
                Lifetime = 2
            })
        end
            
            -- Volver a la posici√≥n principal de Wave 4
            gotoWavePosition(4, 3)
            wait(0.5)
        else
            -- Si todos los regalos visibles ya fueron procesados, limpiar la lista
            -- para permitir que se procesen nuevamente en caso de que aparezcan nuevos
            if #allGifts > 0 then
                processedGifts = {}
                if debug then
                    print("Reiniciando lista de regalos procesados en Wave 4")
                end
            end
            
            -- Esperar un momento antes de buscar m√°s regalos
            wait(0.5)
        end
        
        return false -- Seguir en Wave 4
    end
    
    --[[
    
    wave 5
    
    
    ]]--
    
    
    
    
    
    -- Funci√≥n para el control de Wave 5
    -- Funci√≥n para el control de Wave 5
    wave5Started = false -- Definir fuera de la funci√≥n
    
    
    doWave5 = function()
        waveStartTime = tick()
        if not farm then return false end
        
        if debug then
            print("Ejecutando l√≥gica de Wave 5")
        end
    
        -- Si wave5 ya se ejecut√≥, no repetir
        if not wave5Started then
            equipWeapon("Mega-Pow")
            equipItem("Mega-Pow")
            gotoWavePosition(5, 1)
            gotoWavePosition(5, 2)
            gotoWavePosition(5, 3)
            gotoWavePosition(5, 4)
            setupBodyVelocity()
            wave5Started = true -- Ahora ya no se ejecutar√° m√°s de una vez
        end
    
        -- Buscar el NPC "A present...?" o "Supreme Giftbox, Rocky" en workspace.NPCs
        local targetNPC = nil
    
        -- Primero intentamos encontrar "A present...?"
        for _, npc in pairs(workspace.NPCs:GetChildren()) do
            if npc.Name == "A present...?" then
                targetNPC = npc
                if debug then 
                    print("NPC 'A present...?' encontrado")
                end
                break
            end
        end
    
        -- Si no encontramos "A present...?", buscamos "Supreme Giftbox, Rocky"
        if not targetNPC then
            if workspace.NPCs:FindFirstChild("Supreme Giftbox, Rocky") then
                targetNPC = workspace.NPCs["Supreme Giftbox, Rocky"]
                if debug then
                    print("NPC 'Supreme Giftbox, Rocky' encontrado con √≠ndice directo")
                end
            else
                for _, npc in pairs(workspace.NPCs:GetChildren()) do
                    if npc.Name == "Supreme Giftbox, Rocky" then
                        targetNPC = npc
                        if debug then
                            print("NPC 'Supreme Giftbox, Rocky' encontrado con b√∫squeda")
                        end
                        break
                    end
                end
            end
        end
    
        -- NUEVO: Si no encontramos ning√∫n NPC, buscar YearGiftAniBoss24 en workspace.Effects.PresentModels
        local bossGiftsFound = false
        if not targetNPC then
            local bossGifts = {}
            
            -- Buscar en workspace.Effects.PresentModels
            pcall(function()
                if workspace.Effects and workspace.Effects.PresentModels then
                    for _, gift in pairs(workspace.Effects.PresentModels:GetChildren()) do
                        if gift.Name == "YearGiftAniBoss24" then
                            table.insert(bossGifts, gift)
                            if debug then
                                print("YearGiftAniBoss24 encontrado en Effects.PresentModels")
                            end
                        end
                    end
                end
            end)
            
            -- Si encontramos regalos especiales, ir a ellos
            if #bossGifts > 0 then
                bossGiftsFound = true
                for _, gift in ipairs(bossGifts) do
                    local giftPos = getObjectPosition(gift)
                    if giftPos then
                        if debug then
                            print("Yendo a YearGiftAniBoss24 en posici√≥n: " .. tostring(giftPos))
                        end
                        
                        -- Tween al regalo especial - acercarse lo suficiente para la interacci√≥n
                        tween(giftPos)
                        wait(1)
                        
                        -- MEJORADO: Secuencia de interacci√≥n con el ProximityPrompt
                        pcall(function()
                            -- Primero presionar E para activar la interacci√≥n
                            vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                            wait(0.2)
                            vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                            
                            wait(0.5) -- Esperar un momento
                            
                            -- Buscar el ProximityPrompt en la estructura del objeto
                            local proximityPrompt = nil
                            
                            -- Buscar en la estructura espec√≠fica que vemos en la imagen
                            if gift:FindFirstChild("BottomMiddle") and 
                               gift.BottomMiddle:FindFirstChild("ProximityPrompt") then
                                proximityPrompt = gift.BottomMiddle.ProximityPrompt
                                if debug then
                                    print("ProximityPrompt encontrado en BottomMiddle")
                                end
                            else
                                -- B√∫squeda recursiva como respaldo
                                for _, descendant in pairs(gift:GetDescendants()) do
                                    if descendant:IsA("ProximityPrompt") then
                                        proximityPrompt = descendant
                                        if debug then
                                            print("ProximityPrompt encontrado en b√∫squeda recursiva")
                                        end
                                        break
                                    end
                                end
                            end
                            
                            -- Si encontramos el ProximityPrompt, activarlo
                            if proximityPrompt then
                                -- Intentar fireproximityprompt varias veces para asegurar la interacci√≥n
                                for i = 1, 3 do
                                    if debug then
                                        print("Intento " .. i .. " de fireproximityprompt")
                                    end
                                    
                                    fireproximityprompt(proximityPrompt)
                                    wait(0.5)
                                end
                                
                                -- Presionar E nuevamente como respaldo
                                vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                wait(0.2)
                                vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                
                                if debug then
                                    print("Secuencia de interacci√≥n completa con YearGiftAniBoss24")
                                end
                            else
                                if debug then
                                    print("No se encontr√≥ ProximityPrompt, usando solo keypress")
                                end
                                
                                -- Si no encontramos el ProximityPrompt, intentar con m√°s keypresses
                                for i = 1, 3 do
                                    vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                    wait(0.2)
                                    vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                    wait(0.3)
                                end
                            end
                        end)
                        
                        -- Esperar un momento para que se complete la interacci√≥n
                        wait(2)
                    end
                end
                
                wait(1)
                return false -- Continuar en Wave 5
            end
        end
    
        -- NUEVO: Si no hay NPCs ni regalos, tween a la posici√≥n especificada
        if not targetNPC and not bossGiftsFound then
            if debug then
                print("No se encontraron NPCs ni YearGiftAniBoss24, yendo a posici√≥n alternativa")
            end
            
            -- Posici√≥n alternativa cuando no hay objetivos
            local alternativePosition = Vector3.new(-4345, 43, -5)
            
            -- Notificar al usuario
            if debug then
                Window:Notify({
                Title = "Wave 5 - Sin objetivos",
                Description = "No se encontraron objetivos. Yendo a posici√≥n alternativa.",
                Lifetime = 3
            })
        end
            
            -- Ir a la posici√≥n alternativa
            tween(alternativePosition)
            wait(2)
            
            return false -- Continuar en Wave 5
        end
    
        -- S√≥lo continuar si encontramos el NPC objetivo
        if targetNPC then
            if targetNPC:FindFirstChild("HumanoidRootPart") then
                local targetPosition = targetNPC.HumanoidRootPart.Position
                local playerPosition = player.Character.HumanoidRootPart.Position
                
                -- NUEVO: Verificar si el NPC est√° saltando o ha aterrizado
                local isJumping = targetPosition.Y > 100 -- Si Y > 100, est√° saltando
                local isOnGround = targetPosition.Y >= 60 and targetPosition.Y <= 70 -- Si Y est√° entre 60-70, est√° en el suelo
                local isBelowPlayer = targetPosition.Y < playerPosition.Y -- Si est√° por debajo del jugador
                
                if debug then
                    print("Posici√≥n Y del NPC: " .. targetPosition.Y)
                    print("¬øEst√° saltando? " .. tostring(isJumping))
                    print("¬øEst√° en el suelo? " .. tostring(isOnGround))
                    print("¬øEst√° debajo del jugador? " .. tostring(isBelowPlayer))
                end
                
                -- NUEVO: Solo disparar si el NPC est√° en el suelo (despu√©s de saltar) y por debajo del jugador
                if (isOnGround or not isJumping) and isBelowPlayer then
                    if debug then
                        print("Condiciones cumplidas para disparar: NPC en suelo o no saltando, y debajo del jugador")
                    end
                    
                    local args = {
                        [1] = true,
                        [2] = targetPosition
                    }
                    
                    local character = game:GetService("Players").LocalPlayer.Character
                    if character and character:FindFirstChild("Mega-Pow") then
                        character:FindFirstChild("Mega-Pow").MinigunHandleServer.input:InvokeServer(unpack(args))
                        if debug then
                            
                        print("Disparando a '" .. targetNPC.Name .. "' en la posici√≥n: " .. tostring(targetPosition))
                        end
                    else
                        warn("No megapow ü§î")
                        equipWeapon("Mega-Pow")
                    end
                else
                    if debug then
                        print("No disparando: NPC est√° saltando o no est√° debajo del jugador")
                    end
                end
            else
                warn("El NPC objetivo no tiene HumanoidRootPart.")
            end
        else
            warn("No se encontr√≥ ning√∫n NPC objetivo ni YearGiftAniBoss24.")
        end
    
        wait(1)
        return false -- Seguir en Wave 5
    end
    
    
    -- Tabla de funciones de wave para acceso f√°cil
    local waveFunctions = {
        [1] = doWave1,
        [2] = doWave2,
        [3] = doWave3,
        [4] = doWave4,
        [5] = doWave5
    }
    
    -- Funci√≥n para verificar si todas las funciones de wave est√°n definidas
    local function verificarWaves()
        print("wowGyat: ")
        print("Wave 1: " .. (type(doWave1) == "function" and "OK" or "FALTA"))
        print("Wave 2: " .. (type(doWave2) == "function" and "OK" or "FALTA"))
        print("Wave 3: " .. (type(doWave3) == "function" and "OK" or "FALTA"))
        print("Wave 4: " .. (type(doWave4) == "function" and "OK" or "FALTA"))
        print("Wave 5: " .. (type(doWave5) == "function" and "OK" or "FALTA"))
    end
    
    -- Verificar funciones de wave
    verificarWaves()
    
    -- Funci√≥n principal para farming que maneja todas las waves
    local function StartFarm()
        if not farm then 
            -- Desconectar Heartbeat al detener el farming
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
            return 
        end
    
    
        spawn(function()
            if debug then
                print("Iniciando farm en Wave " .. wave)
            end
            
            while farm do
                -- Usar el sistema de funciones con manejo de errores
                local currentWaveFunction = waveFunctions[wave]
                if not currentWaveFunction then
                    if debug then
                        print("Error: Funci√≥n para Wave " .. wave .. " no encontrada")
                    end
                    -- Cambiar a Wave 1 para recuperar el sistema
                    wave = 1
                    if waveParagraph then
                        waveParagraph:UpdateBody("Wave 1!")
                    end
                    wait(2)
                    -- 'continue' no existe en Lua, usamos un else para el resto del c√≥digo
                else
                    -- Usar pcall para evitar que un error detenga todo el proceso
                    local success, waveChanged = pcall(function()
                        return currentWaveFunction()
                    end)
                    
                    if not success then
                        if debug then
                            print("Error en Wave " .. wave .. ": " .. tostring(waveChanged))
                            if debug then
                                Window:Notify({
                                Title = "Error recuperable",
                                Description = "Error en Wave " .. wave .. ". Reintentando...",
                                Lifetime = 3
                            })
                        end
                        end
                        wait(2)
                    end
                    
                    if not farm then 
                        -- Desconectar Heartbeat al detener el farming
                        if heartbeatConnection then
                            heartbeatConnection:Disconnect()
                            heartbeatConnection = nil
                        end
                        break 
                    end
                end
                wait(0.1)
            end
            
            if debug then
                print("Farm detenido")
            end
        end)
    end

--[[












anni logica arriba


















]]--




function createTween(instance, tweenInfo, properties, isMissionTween)
    local tween = originalTweenCreate(TweenService, instance, tweenInfo, properties)
    
    if isMissionTween then
        -- Si es tween de misi√≥n, agregarlo a la lista espec√≠fica
        table.insert(questTweens, tween)
    else
        -- Si es tween regular, agregarlo a la lista normal
        table.insert(activeTweens, tween)
    end
    
    tween.Completed:Connect(function(status)
        -- Eliminar de la lista regular
        for i, t in ipairs(activeTweens) do
            if t == tween then
                table.remove(activeTweens, i)
                break
            end
        end
        
        -- Eliminar de la lista de tweens de misiones
        for i, t in ipairs(questTweens) do
            if t == tween then
                table.remove(questTweens, i)
                break
            end
        end
    end)
    
    return tween
end

-- Funci√≥n actualizada para cancelar tweens con opci√≥n de preservar tweens de misi√≥n
function cancelAllActiveTweens(preserveMissionTweens)
    -- Si preserveMissionTweens es true, solo cancelamos tweens regulares
    if preserveMissionTweens then
        for _, tween in ipairs(activeTweens) do
            pcall(function() tween:Cancel() end)
        end
        activeTweens = {}
    else
        -- Cancelar todos los tweens (regulares y de misi√≥n)
        for _, tween in ipairs(activeTweens) do
            pcall(function() tween:Cancel() end)
        end
        activeTweens = {}
        
        for _, tween in ipairs(questTweens) do
            pcall(function() tween:Cancel() end)
        end
        questTweens = {}
    end
end

-- Variables principales
local player = game:GetService("Players").LocalPlayer
local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

task.spawn(function()

    Window:Notify({
        Title = "Anti-AFK",
        Description = "antiafk enabled",
        Lifetime = 3
    })
    

    while true do
        pcall(function() 
            
            -- Use VirtualInputManager instead of keypress/keyrelease
            -- Convert hex keys to KeyCode enum values
            local keys = {Enum.KeyCode.Z, Enum.KeyCode.X, Enum.KeyCode.V, Enum.KeyCode.L} -- Equivalent to 0x5A, 0x58, 0x56, 0x4C
            local randomKey = keys[math.random(1, #keys)]
            
            -- Send key down event
            vim:SendKeyEvent(true, randomKey, false, game)
            task.wait(0.05)
            -- Send key up event
            vim:SendKeyEvent(false, randomKey, false, game)
            
        end)
        
        if math.random(1, 2) == 1 then
            Window:Notify({
                Title = "Anti-AFK",
                Description = "OUSI.HUB ON TOP",
                Lifetime = 2
            })
        end
        
        for i = 1, 6 do
            task.wait(10)
        end
    end
end)

local function calcularDuracionTween(origen, destino, velocidad)
    if typeof(origen) == "Vector3" and typeof(destino) == "Vector3" then
        local distancia = (Vector3.new(destino.X, 0, destino.Z) - Vector3.new(origen.X, 0, origen.Z)).Magnitude
        return tonumber(distancia / velocidad) -- Aseguramos que retorne un n√∫mero
    end
    return 1 -- valor por defecto si hay error (cambiado de 0 a 1 para evitar divisi√≥n por cero)
end
-- Variable global para control
_G.KaitunActive = false
-- Eliminamos la variable QuestActive ya que ahora ser√° parte integral del auto farm

-- Variable para controlar si ya est√° iniciado el auto shooting
local autoShootingStarted = false
-- Eliminamos questLoopStarted ya que ahora se manejar√° diferente

local function startAutoShooting()
    -- Si ya est√° iniciado, no hacer nada
    if autoShootingStarted then return end
    autoShootingStarted = true

    local runService = game:GetService("RunService")
    local lastShot = 0
    local isReloading = false
    local targetMarker = nil
    
    -- Variable para controlar ciclo de quest
    local lastQuestCheck = 0
    local questCheckCooldown = 5 -- Verificar cada 5 segundos
    
    -- Variable para rastrear si el ciclo de misi√≥n est√° activo
    local isMissionCycleActive = false
    
    -- Funci√≥n para realizar el ciclo de quest
    local function performQuestCycle()
        -- Variable para seguimiento del BodyVelocity
        local bv = nil
        
        -- Funci√≥n de limpieza para asegurar que los recursos se eliminen en caso de error
        local function cleanupResources()
            -- Eliminar BodyVelocity si existe
            if bv and bv.Parent then
                bv:Destroy()
                bv = nil
            end
        end
        
        -- Usar pcall para todo el proceso y garantizar limpieza de recursos
        local success, err = pcall(function()
            -- Verificar si el personaje existe
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
                
                return 
            end
            
            -- Verificar si el nivel es mayor o igual a 190
            local playerLevel = 0
            local levelSuccess = pcall(function()
                local hud = player.PlayerGui:FindFirstChild("HUD")
                if not hud then return end
                
                local main = hud:FindFirstChild("Main") 
                if not main then return end
                
                local bars = main:FindFirstChild("Bars")
                if not bars then return end
                
                local experience = bars:FindFirstChild("Experience")
                if not experience then return end
                
                local detail = experience:FindFirstChild("Detail")
                if not detail then return end
                
                local levelLabel = detail:FindFirstChild("Level")
                if not levelLabel then return end
                
                local levelText = levelLabel.Text or ""
                local levelNumber = levelText:match("Level%s*:?%s*(%d+)") or levelText:match("(%d+)")
                if levelNumber then
                    playerLevel = tonumber(levelNumber)
                end
            end)
            
            -- Si no se pudo obtener el nivel o es menor a 190, no continuar con la quest
            if not levelSuccess or playerLevel < 190 then
                Window:Notify({
                    Title = "Ousi.HUB",
                    Description = "no level for quest: " .. playerLevel .. " (req 190+)",
                    Lifetime = 3
                })
                return
            end
            
            -- Posiciones
            local currentPos = player.Character.HumanoidRootPart.Position
            local questPos = Vector3.new(7736, -2176, -17221)
            local farmPos = Vector3.new(7820, -2160, -17145)
            
            
            
            -- Crear BodyVelocity para evitar ca√≠das
            bv = Instance.new("BodyVelocity")
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            bv.Parent = player.Character.HumanoidRootPart
            
            -- Guardar todos los tweens activos para cancelarlos antes de crear uno nuevo
            -- pero preservar los tweens de misi√≥n
            cancelAllActiveTweens(true)
            
            -- Sistema mixto: TP para subir, tween para XZ, TP para bajar
            -- 1. TP directo para subir a una altura segura
            local elevationY = 100
            local elevatedPos = Vector3.new(currentPos.X, questPos.Y + elevationY, currentPos.Z)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            player.Character.HumanoidRootPart.CFrame = CFrame.new(elevatedPos)
            task.wait(0.2) -- Peque√±a pausa para estabilizar
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end

            -- 2. Tween para movimiento horizontal XZ
            local horizontalPos = Vector3.new(questPos.X, questPos.Y + elevationY, questPos.Z)
            local tweenDuration = calcularDuracionTween(elevatedPos, horizontalPos, 35)
            local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
            local tween = createTween(player.Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(horizontalPos)}, true)
            
            -- Intentar ejecutar el tween
            tween:Play()
            
            -- Esperar a que termine o falle
            local tweenSuccess = pcall(function()
                tween.Completed:Wait()
            end)
            
            if not tweenSuccess then
                cleanupResources()
                
                task.wait(1)
                return performQuestCycle() -- Intentar de nuevo desde el principio
            end
            
            -- Esperar 0.5 segundos antes de hacer TP a Y
            task.wait(0.5)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            -- 3. TP directo para bajar a la posici√≥n exacta
            player.Character.HumanoidRootPart.CFrame = CFrame.new(questPos)
            task.wait(0.2) -- Peque√±a pausa para estabilizar
            
            -- Verificar la distancia final
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            local distanceToQuest = (player.Character.HumanoidRootPart.Position - questPos).Magnitude
            
            
            -- Esperar un momento para estabilizar antes de tomar la quest
            task.wait(1)
            
            -- Tomar quest una sola vez
            local args = {
                [1] = {
                    [1] = "takequest",
                    [2] = "Help becky"
                }
            }
            
            local questSuccess = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Quest"):InvokeServer(unpack(args))
            end)
            
            if questSuccess then
                
            else
                
            end
            
            -- Regresar a posici√≥n de farmeo
            
            
            -- Cancelar tweens activos antes de crear uno nuevo
            -- pero preservar los tweens de misi√≥n
            cancelAllActiveTweens(true)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            -- Sistema mixto para el regreso: TP para subir, tween para XZ, TP para bajar
            -- 1. TP directo para subir a una altura segura
            local returnElevatedPos = Vector3.new(questPos.X, questPos.Y + elevationY, questPos.Z)
            player.Character.HumanoidRootPart.CFrame = CFrame.new(returnElevatedPos)
            task.wait(0.2) -- Peque√±a pausa para estabilizar
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end

            -- 2. Tween para movimiento horizontal XZ
            local returnHorizontalPos = Vector3.new(farmPos.X, farmPos.Y + elevationY, farmPos.Z)
            local returnTweenDuration = calcularDuracionTween(returnElevatedPos, returnHorizontalPos, 35)
            local returnTweenInfo = TweenInfo.new(returnTweenDuration, Enum.EasingStyle.Linear)
            local returnTween = createTween(player.Character.HumanoidRootPart, returnTweenInfo, {CFrame = CFrame.new(returnHorizontalPos)}, true)
            
            -- Intentar ejecutar el tween de regreso
            returnTween:Play()
            
            -- Esperar a que termine o falle
            local returnTweenSuccess = pcall(function()
                returnTween.Completed:Wait()
            end)
            
            if not returnTweenSuccess then
                cleanupResources()
                
                task.wait(1)
                -- Reintento directo al TP final
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(farmPos)
                end
            end
            
            -- Esperar 0.5 segundos antes de hacer TP a Y
            task.wait(0.5)
            
            -- Verificar que el personaje sigue existiendo antes de continuar
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                cleanupResources()
                
                return
            end
            
            -- 3. TP directo para bajar a la posici√≥n exacta
            player.Character.HumanoidRootPart.CFrame = CFrame.new(farmPos)
            task.wait(0.2) -- Peque√±a pausa para estabilizar
            
            if returnTweenSuccess then
                local farmPos = Vector3.new(7820, -2160, -17145)
                local distanceToFarm = (player.Character.HumanoidRootPart.Position - farmPos).Magnitude
                
            else
                
            end
            
            return true
        end)
        
        -- Limpieza final garantizada
        cleanupResources()
        
        if not success then
            
            return false
        end
        
        return true
    end
    
    -- Variable para almacenar el √∫ltimo nivel conocido del jugador
    local lastKnownLevel = 0

    -- Funci√≥n robusta para obtener nivel
    local function getPlayerLevel()
        local playerLevel = 0
        pcall(function()
            local hud = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("HUD")
            if not hud then return end
            
            local main = hud:FindFirstChild("Main") 
            if not main then return end
            
            local bars = main:FindFirstChild("Bars")
            if not bars then return end
            
            local experience = bars:FindFirstChild("Experience")
            if not experience then return end
            
            local detail = experience:FindFirstChild("Detail")
            if not detail then return end
            
            local levelLabel = detail:FindFirstChild("Level")
            if not levelLabel then return end
            
            local levelText = levelLabel.Text or ""
            local levelNumber = levelText:match("Level%s*:?%s*(%d+)") or levelText:match("(%d+)")
            
            if levelNumber then
                playerLevel = tonumber(levelNumber)
            end
        end)
        
        return playerLevel
    end

    -- Agregar este c√≥digo para verificar el nivel y activar misiones autom√°ticamente
    task.spawn(function()
        while true do
            if _G.KaitunActive then
                -- Verificar nivel cada 5 segundos (m√°s frecuente)
                local currentLevel = getPlayerLevel()
                
                -- Si es la primera vez que verificamos o hubo un cambio de nivel
                if lastKnownLevel ~= currentLevel then
                    -- Notificar cambio de nivel
                    if lastKnownLevel > 0 then
                        Window:Notify({
                            Title = "Level updated",
                            Description = "Current level: " .. currentLevel,
                            Lifetime = 3
                        })
                    end
                    
                    -- Si alcanzamos nivel 190 y no est√°bamos en √©l antes
                    if lastKnownLevel < 190 and currentLevel >= 190 then
                        -- Notificar con √©nfasis
                        Window:Notify({
                            Title = "LEVEL 190 REACHED!!",
                            Description = "Starting quest cycle NOW!",
                            Lifetime = 5
                        })
                        
                        -- En lugar de intentar tomar la misi√≥n directamente, iniciar el ciclo completo
                        -- que teleporta al personaje a la posici√≥n correcta primero
                        pcall(function()
                            isMissionCycleActive = true
                            performQuestCycle() -- Esta funci√≥n ya teleporta y luego toma la misi√≥n
                            task.wait(1)
                            isMissionCycleActive = false
                        end)
                    end
                    
                    -- Actualizar √∫ltimo nivel conocido
                    lastKnownLevel = currentLevel
                end
                if currentLevel >= 190 then
                    -- Verificar si hay una misi√≥n activa
                    local hasActiveQuest = false
                    pcall(function()
                        local questGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Quest")
                        hasActiveQuest = questGui and questGui.Enabled
                    end)
                    
                    -- Si no hay misi√≥n activa y no estamos en medio de un ciclo de misi√≥n, tomar la misi√≥n
                    if not hasActiveQuest and not isMissionCycleActive then
                        Window:Notify({
                            Title = "Quest Check",
                            Description = "Level 190+ but no active quest. Taking quest...",
                            Lifetime = 3
                        })
                        
                        pcall(function()
                            isMissionCycleActive = true
                            performQuestCycle()
                            task.wait(1)
                            isMissionCycleActive = false
                        end)
                    end
                end
            end
            task.wait(5) -- Verificar cada 5 segundos
        end
    end)

    -- Forzar la toma de la misi√≥n al inicio del farm
    task.spawn(function()
        -- Esperar un poco para que el personaje se estabilice
        task.wait(2)
        
        
        
        -- Usar pcall para evitar errores de thread
        pcall(function()
            isMissionCycleActive = true
            performQuestCycle()
            task.wait(1)
            isMissionCycleActive = false
        end)
    end)
    
    -- Variables para seguimiento de la √∫ltima misi√≥n
    local lastQuestProgress = -1 -- Inicializado en -1 para detectar el primer cambio

    -- Reemplazar completamente la funci√≥n checkQuestProgress con esta versi√≥n espec√≠fica
    local function checkQuestProgress()
        local needsNewQuest = false
        local currentProgress = 0
        local totalNeeded = 0
        
        pcall(function()
            -- Usar la ruta exacta proporcionada
            local progressText = game:GetService("Players").LocalPlayer.PlayerGui.Quest.Main.Info.Top.Progress.ContentText
            
            if progressText then
                -- Extraer los n√∫meros usando pattern matching
                local current, total = string.match(progressText, "(%d+)%s*/%s*(%d+)")
                
                if current and total then
                    currentProgress = tonumber(current)
                    totalNeeded = tonumber(total)
                    
                    -- Verificar si necesitamos una nueva misi√≥n bas√°ndonos en la l√≥gica descrita:
                    -- Si antes ten√≠amos progreso y ahora volvimos a 0, significa que la misi√≥n est√° completa
                    if lastQuestProgress > 0 and currentProgress == 0 then
                        needsNewQuest = true
                        
                    elseif currentProgress > 0 and (currentProgress ~= lastQuestProgress) then
                        -- Si hay progreso activo, notificar ocasionalmente
                        if math.random(1, 10) == 1 then
                            
                        end
                    end
                    
                    -- Actualizar el √∫ltimo progreso conocido
                    lastQuestProgress = currentProgress
                end
            end
        end)
        
        -- Si se detect√≥ "0/5" despu√©s de tener progreso, o si no hay misi√≥n activa
        return needsNewQuest
    end

    -- Modificar el bucle de verificaci√≥n peri√≥dica
    task.spawn(function()
        local lastQuestCheck = tick()
        local questCheckCooldown = 10 -- Verificar cada 10 segundos
        
        while _G.KaitunActive do
            local currentTime = tick()
            
            -- Verificaci√≥n normal
            if currentTime - lastQuestCheck >= questCheckCooldown then
                lastQuestCheck = currentTime
                
                -- Verificar si estamos en la zona de farmeo
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local farmPos = Vector3.new(7820, -2160, -17145)
                    local distToFarm = (player.Character.HumanoidRootPart.Position - farmPos).Magnitude
                    
                    if distToFarm <= 50 and not isMissionCycleActive then
                        -- Usar pcall para evitar errores de thread
                        pcall(function()
                            local needsQuest = checkQuestProgress()
                            
                            if needsQuest then
                                isMissionCycleActive = true
                                -- Pausar el disparo temporalmente
                                lastShot = tick() + 10
                                performQuestCycle()
                                task.wait(1)
                                isMissionCycleActive = false
                            end
                        end)
                    end
                end
            end
            
            task.wait(1)
        end
    end)

    -- Corregir funci√≥n para Gun Mastery (l√≠mite 500)
    task.spawn(function()
        -- Variable para seguimiento de estado de GunMastery
        local masteryCompleted = false
        
        while true do
            if _G.KaitunActive and not masteryCompleted then
                pcall(function()
                    -- Abrir men√∫ de estad√≠sticas si no est√° abierto
                    local statsGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Statistics")
                    
                    
                    -- Obtener valor actual de Gun Mastery
                    local currentMastery = 0
                    local success = pcall(function()
                        local statsGui = game:GetService("Players").LocalPlayer.PlayerGui.Statistics
                        if not statsGui then return end
                        
                        local main = statsGui.Main
                        if not main then return end
                        
                        local stats = main.Stats
                        if not stats then return end
                        
                        local gunMastery = stats.GunMastery
                        if not gunMastery then return end
                        
                        local amountLabel = gunMastery.Amount
                        if not amountLabel then return end
                        
                        -- Intentar diferentes formas de obtener el valor
                        local masteryText = amountLabel.Text or amountLabel.ContentText or ""
                        currentMastery = tonumber(string.match(masteryText, "%d+")) or 0
                    end)
                    
                    -- Verificar si ya alcanzamos el l√≠mite
                    if currentMastery >= 500 then
                        Window:Notify({
                            Title = "GunMastery completo",
                            Description = "¬°Alcanzado 500/500 GunMastery!",
                            Lifetime = 5
                        })
                        masteryCompleted = true
                        return
                    end
                    
                    -- Obtener puntos disponibles
                    local points = 0
                    pcall(function()
                        local statsGui = game:GetService("Players").LocalPlayer.PlayerGui.Statistics
                        if not statsGui then return end
                        
                        local main = statsGui.Main
                        if not main then return end
                        
                        local topOptions = main.TopOptions
                        if not topOptions then return end
                        
                        local availableSPLabel = topOptions.AvailableSP
                        if not availableSPLabel then return end
                        
                        local pointsText = availableSPLabel.Text
                        points = tonumber(pointsText:match("(%d+)")) or 0
                    end)
                    
                    
                    
                    -- Aplicar punto solo si no hemos alcanzado 500
                    local args = {
                        [1] = "GunMastery",
                        [2] = nil,
                        [3] = 1
                    }
                    
                    local success = pcall(function()
                        game:GetService("ReplicatedStorage").Events.stats:FireServer(unpack(args))
                    end)
                    
                    if success and math.random(1, 5) == 1 then -- Mostrar solo ocasionalmente
                        
                    end
                end)
                
                task.wait(0.5) -- Medio segundo entre intentos para ser m√°s eficiente
            else
                task.wait(2) -- Esperar m√°s tiempo cuando est√° inactivo o ya completado
            end
        end
    end)

    local shootConfig = {
        autoReload = true,
        checkRaycast = false,
        targetPart = "Head",
        visualizeTarget = true,
        range = math.huge
    }

    local function createTargetMarker()
        -- Si ya existe, no crear de nuevo
        if targetMarker and targetMarker.Parent then return end
        
        -- Crear una sola vez en un pcall para evitar errores
        local success = pcall(function()
            targetMarker = Instance.new("Part")
            targetMarker.Anchored = true
            targetMarker.CanCollide = false
            targetMarker.Size = Vector3.new(0.5, 0.5, 0.5)
            targetMarker.Color = Color3.fromRGB(255, 0, 0)
            targetMarker.Material = Enum.Material.Neon
            targetMarker.Shape = Enum.PartType.Ball
            targetMarker.Transparency = 0.5
            
            -- Verificar si workspace existe antes de continuar
            if workspace then
                targetMarker.Parent = workspace
            else
                warn("Workspace no disponible para agregar targetMarker")
                return
            end
            
            -- Configurar para que se autodestruya si _G.KaitunActive se desactiva
            task.spawn(function()
                while targetMarker and targetMarker.Parent do
                    if not _G.KaitunActive then
                        if targetMarker and targetMarker.Parent then
                            targetMarker:Destroy()
                            targetMarker = nil
                        end
                        return -- Usar return en lugar de break
                    end
                    task.wait(1)
                end
            end)
        end)
        
        if not success then
            
        end
    end

    local function findClosestTarget()
        -- Usar pcall para evitar errores
        local success, result = pcall(function()
            local closestDistance = shootConfig.range
            local closest = nil
            
            -- Verificar si hay NPCs antes de iterar
            if not workspace or not workspace:FindFirstChild("NPCs") then 
                return nil 
            end
            
            -- Cache local para almacenar piezas objetivo ya encontradas
            local targetParts = {}
            
            -- Solo buscar en los hijos directos para evitar GetDescendants
            for _, npc in ipairs(workspace.NPCs:GetChildren()) do
                -- Verificaci√≥n r√°pida del nombre
                if npc and npc.Name == "Fishman Karate User" then
                    -- Verificar la humanoid solo una vez
                    local humanoid = npc:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        -- Obtener S√ìLO la parte "Head"
                        local headPart = targetParts[npc] or npc:FindFirstChild("Head")
                        
                        -- Guardar en cach√© para futuras referencias
                        if headPart then targetParts[npc] = headPart end
                        
                        if headPart and player and player.Character and 
                           player.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (player.Character.HumanoidRootPart.Position - headPart.Position).Magnitude
                            
                            -- Evitar raycast si no es necesario
                            local canSee = true
                            if shootConfig.checkRaycast and distance < closestDistance then
                                local ray = Ray.new(player.Character.HumanoidRootPart.Position, 
                                                   headPart.Position - player.Character.HumanoidRootPart.Position)
                                local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {player.Character, workspace.NPCs})
                                canSee = hit == nil
                            end
                            
                            if distance < closestDistance and canSee then
                                closestDistance = distance
                                closest = {npc = npc, part = headPart, distance = distance}
                            end
                        end
                    end
                end
            end
            
            return closest
        end)
        
        if not success then
            warn("Error en findClosestTarget:", result)
            return nil
        end
        
        return result
    end

    local function reloadRifle()
        -- Si ya est√° recargando, no intentar recargar de nuevo
        if isReloading then return false end
        
        -- Marcar como recargando
        isReloading = true
        
        -- Preparar argumentos
        local args = {
            [1] = "reload",
            [2] = { ["Gun"] = "Rifle" }
        }
        
        -- Intentar recargar con pcall para evitar errores
        local success = false
        task.spawn(function()
            success = pcall(function()
                if not game:GetService("ReplicatedStorage") or
                   not game:GetService("ReplicatedStorage"):FindFirstChild("Events") or
                   not game:GetService("ReplicatedStorage").Events:FindFirstChild("CIcklcon") or
                   not game:GetService("ReplicatedStorage").Events.CIcklcon:FindFirstChild("gunFunctions") then
                    return false
                end
                
                return game:GetService("ReplicatedStorage").Events.CIcklcon.gunFunctions:InvokeServer(unpack(args))
            end)
            
            -- Asegurar que isReloading vuelva a false despu√©s de 1 segundo, incluso si falla
            task.delay(0.2, function() 
                isReloading = false
            end)
        end)
        
        return success
    end

    local function shootTarget(target)
        -- Usar pcall para seguridad
        local success, result = pcall(function()
            if not target or not target.part then return false end
            
            -- Comprobaci√≥n de cooldown para reducir llamadas
            local currentTime = tick()
            if currentTime - lastShot < 0.2 then return false end
            
            -- Verificar que tenemos el rifle equipado
            if not player or not player.Character then return false end
            
            local rifleGun = player.Character:FindFirstChild("RifleGun")
            if not rifleGun or not rifleGun:FindFirstChild("Hole") then return false end
            
            -- Solo actualizar lastShot si realmente vamos a disparar
            lastShot = currentTime
            
            -- Preparar los argumentos una sola vez
            local args1 = {
                [1] = "fire",
                [2] = {
                    ["Start"] = rifleGun.Hole.CFrame,
                    ["Gun"] = "Rifle",
                    ["joe"] = "true",
                    ["Position"] = target.part.Position
                }
            }
            
            -- Usar pcall para la primera llamada
            local success1 = pcall(function()
                if not game:GetService("ReplicatedStorage") or
                   not game:GetService("ReplicatedStorage"):FindFirstChild("Events") or
                   not game:GetService("ReplicatedStorage").Events:FindFirstChild("CIcklcon") then
                    return false
                end
                
                game:GetService("ReplicatedStorage").Events.CIcklcon:FireServer(unpack(args1))
                return true
            end)

            -- Solo ejecutar el segundo disparo si el primero tuvo √©xito
            if success1 then
                -- Intentar conseguir el RemoteEvent una sola vez con cach√©
                local guncastRemote = game:GetService("ReplicatedStorage"):FindFirstChild("guncast", true)
                if guncastRemote and guncastRemote:IsA("RemoteEvent") then
                    local args2 = {
                        [1] = target.part.Position,
                        [2] = target.part,
                        [3] = 0.1
                    }
                    pcall(function()
                        guncastRemote:FireServer(unpack(args2))
                    end)
                end
            end
            
            return success1
        end)
        
        if not success then
            warn("Error en shootTarget:", result)
            return false
        end
        
        return result
    end

    local function mainLoop()
        -- Usar pcall en todo el mainLoop para evitar errores fatales
        pcall(function()
            if shootConfig.visualizeTarget then
                createTargetMarker()
            end
            
            -- Variables para throttling y optimizaci√≥n
            local lastTargetCheck = 0
            local targetCheckCooldown = 0.1  -- Verificar objetivo cada 100ms
            local currentTarget = nil
            local consecutiveFails = 0
            local maxConsecutiveFails = 5
            
            -- Crear una √∫nica conexi√≥n para el Heartbeat con protecci√≥n
            local connection
            local connectionSuccess = pcall(function()
                connection = runService.Heartbeat:Connect(function()
                    -- Usar pcall en el callback para evitar que un error detenga todo el script
                    pcall(function()
                        -- Si se desactiva el auto farm o hay un ciclo de misi√≥n activo, pausar temporalmente
                        if not _G.KaitunActive or isMissionCycleActive then
                            if not _G.KaitunActive and connection then
                                connection:Disconnect()
                                connection = nil
                                autoShootingStarted = false
                                if targetMarker and targetMarker.Parent then
                                    targetMarker:Destroy()
                                    targetMarker = nil
                                end
                            end
                            return -- Usar return en lugar de break
                        end

                        -- Verificaciones de throttling
                        local currentTime = tick()
                        
                        -- Solo comprobar el car√°cter a intervalos regulares
                        if not player then return end
                        local character = player.Character
                        if not character then return end
                        
                        local rifleGun = character:FindFirstChild("RifleGun")
                        if not rifleGun then return end
                        
                        -- Comprobar objetivo solo peri√≥dicamente para reducir carga
                        if currentTime - lastTargetCheck >= targetCheckCooldown then
                            lastTargetCheck = currentTime
                            currentTarget = findClosestTarget()
                            
                            -- Actualizar el marcador visual solo cuando cambia el objetivo
                            if targetMarker and targetMarker.Parent and currentTarget and currentTarget.part then
                                targetMarker.Position = currentTarget.part.Position
                                targetMarker.Transparency = 0.5
                            elseif targetMarker and targetMarker.Parent then
                                targetMarker.Transparency = 1
                            end
                        end
                        
                        -- Solo disparar si hay un objetivo v√°lido
                        if currentTarget then
                            local success = shootTarget(currentTarget)
                            if success then
                                consecutiveFails = 0
                            else
                                consecutiveFails = consecutiveFails + 1
                                -- Si hay demasiados fallos consecutivos, intentar recargar
                                if consecutiveFails >= maxConsecutiveFails and shootConfig.autoReload then
                                    reloadRifle()
                                    consecutiveFails = 0
                                end
                            end
                        end
                    end)
                end)
            end)
            
            -- Si no se pudo crear la conexi√≥n, notificar
            if not connectionSuccess or not connection then
                
            end
        end)
    end

    -- Iniciar el mainLoop con protecci√≥n adicional
    pcall(mainLoop)

end

-- Funciones b√°sicas necesarias
local function checkPeli()
    -- Verifica si PlayerGui y HUD existen
    if not player or not player:FindFirstChild("PlayerGui") then return false end
    if not player.PlayerGui:FindFirstChild("HUD") then return false end
    if not player.PlayerGui.HUD:FindFirstChild("Main") then return false end
    if not player.PlayerGui.HUD.Main:FindFirstChild("Peli") then return false end
    if not player.PlayerGui.HUD.Main.Peli:FindFirstChild("TextLabel") then return false end

    -- Extraer solo los n√∫meros del texto
    local peliLabel = player.PlayerGui.HUD.Main.Peli.TextLabel
    local peliAmount = peliLabel.Text:gsub("%D", "")
    
    return tonumber(peliAmount) or 0
end


local function checkGun()
    if player.Backpack:FindFirstChild("Rifle") or (player.Character and player.Character:FindFirstChild("Rifle")) then
        return true
    end
    return false
end

local function checkMega()
    if player.Backpack:FindFirstChild("Mega-Pow") or (player.Character and player.Character:FindFirstChild("Mega-Pow")) then
        return true
    end
    return false
end



-- Funci√≥n corregida para calcular la duraci√≥n del tween


-- Funci√≥n simple para comprar rifle
local function getRifle()
    pcall(function()
        ReplicatedStorage:WaitForChild("Events"):WaitForChild("Tools"):InvokeServer("equip", "Rifle")
    end)
    return checkGun()
end

-- Funci√≥n mejorada para teleport con triple intento y reset
local function teleportToRifleArea()
    -- Si ya tiene el rifle equipado y est√° en posici√≥n de farmeo, simplemente retornar
    if player.Character and player.Character:FindFirstChild("RifleGun") then
        -- No mostrar notificaci√≥n aqu√≠
        return true
    end
    
    local TweenService = game:GetService('TweenService')
    local targetPosition = Vector3.new(7982, -2149, -17075)
    if _G.KaitunActive and checkGun() then
        local currentPos = player.Character.HumanoidRootPart.Position


            
        Window:Notify({ Title = "Auto Farm", Description = "Teleported to final position", Lifetime = 3 })

            if (currentPos - targetPosition).Magnitude <= 500 then
                local bv2 = Instance.new("BodyVelocity")
                bv2.Velocity = Vector3.new(0, 0, 0)
                bv2.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv2.Parent = player.Character.HumanoidRootPart
                local newPos = Vector3.new(currentPos.X, currentPos.Y + 15, currentPos.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(newPos)
                task.wait(0.5)  -- Peque√±a pausa para estabilizar
                
                local tweenTarget = Vector3.new(7820, newPos.Y, -17145)
                local tweenDuration = calcularDuracionTween(newPos, tweenTarget, 35)
                local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
                local tween = createTween(player.Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(tweenTarget)}, true)
                tween:Play()
                tween.Completed:Wait()
                
                local finalPos = Vector3.new(tweenTarget.X, -2160, tweenTarget.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                bv2:Destroy()
    
                -- Insertado: Simulaci√≥n de keypress si se encuentra 'Rifle' en el Hotbar
                equipWeapon("Rifle")
            return true
        end
    end
    
    local success = false
    
    -- No limitamos intentos, seguiremos hasta tener √©xito
    while not success do
        -- Realizamos 3 ciclos de teleport + reset
        for i = 1, 3 do
            -- Teleport inicial al √°rea
            pcall(function()
                player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
                task.wait(0.2) -- Peque√±a pausa para estabilizar
                
                -- Reset del personaje
                ReplicatedStorage:WaitForChild("Events"):WaitForChild("KnockedOut"):FireServer("self")
                task.wait(0.3) -- Esperar despu√©s del KnockedOut
                
                -- Notificar el intento actual
                Window:Notify({
                    Title = "Attempt " .. i .. "/3",
                    Description = "Teleport + Reset completed",
                    Lifetime = 2
                })
            end)
            
            -- Peque√±a pausa entre ciclos
            task.wait(1)
        end
        
        -- Verificar si permanece en el √°rea durante 25 segundos
        local startTime = tick()
        local inArea = true
        
        -- Notificar al usuario que estamos verificando
        Window:Notify({
            Title = "Checking position",
            Description = "Waiting for stability (25s)...",
            Lifetime = 3
        })
        
        -- Loop de verificaci√≥n durante 25 segundos
        while tick() - startTime < 25 and inArea do
            -- Comprobar si sigue en el √°rea (radio 50)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local currentPos = player.Character.HumanoidRootPart.Position
                local distance = (currentPos - targetPosition).Magnitude
                
                if distance > 50 then
                    inArea = false
                    Window:Notify({
                        Title = "Out of area",
                        Description = "Retrying teleport in 30 seconds...",
                        Lifetime = 5
                    })
                end
            else
                inArea = false
            end
            
            task.wait(0.5) -- Comprobar cada 0.5 segundos
        end
        
        -- Si complet√≥ los 25 segundos en el √°rea, marcar como √©xito
        if inArea then
            local currentPos = player.Character.HumanoidRootPart.Position
            local checkPos = Vector3.new(7982, -2149, -17075)
            local distance = (currentPos - checkPos).Magnitude

            -- Primero establecemos el spawn point
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("SetSpawn"):FireServer()
            wait(0.5)
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("SetSpawn"):FireServer()
            wait(0.5)
            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("SetSpawn"):FireServer()
            wait(2)
            Window:Notify({ Title = "Success", Description = "Spawn point set successfully", Lifetime = 3 })
            
            -- Luego hacemos el tween a la posici√≥n de farmeo
            if distance <= 500 then
                -- Crear BodyVelocity para evitar ca√≠das
                local bv2 = Instance.new("BodyVelocity")
                bv2.Velocity = Vector3.new(0, 0, 0)
                bv2.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv2.Parent = player.Character.HumanoidRootPart

                -- Elevaci√≥n inicial
                local newPos = Vector3.new(currentPos.X, currentPos.Y + 200, currentPos.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(newPos)
                task.wait(0.5)

                -- Tween a la posici√≥n de farmeo
                local tweenTarget = Vector3.new(7820, newPos.Y, -17145)
                local tweenDuration = calcularDuracionTween(newPos, tweenTarget, 35)
                local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear)
                local tween = createTween(player.Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(tweenTarget)}, true)
                tween:Play()
                tween.Completed:Wait()

                -- Posici√≥n final
                local finalPos = Vector3.new(tweenTarget.X, -2160, tweenTarget.Z)
                player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                bv2:Destroy()

                Window:Notify({ Title = "Success", Description = "Moved to farming position", Lifetime = 3 })
            end
            success = true
        else
            -- Esperar 30 segundos antes de reintentar
            Window:Notify({
                Title = "Waiting",
                Description = "Waiting 30 seconds before retrying...",
                Lifetime = 10
            })
            
            local waitStartTime = tick()
            while tick() - waitStartTime < 30 do
                if math.floor(tick() - waitStartTime) % 5 == 0 then
                    local timeLeft = 30 - math.floor(tick() - waitStartTime)
                    Window:Notify({ Title = "Countdown", Description = "Retrying in " .. timeLeft .. " seconds", Lifetime = 2 })
                end
                task.wait(1)
            end
            Window:Notify({ Title = "Retrying", Description = "Retrying teleport...", Lifetime = 3 })
        end
    end
    
    return success
end

-- Funci√≥n para obtener islas
local function getIslands()
    local islandList = {}
    if workspace:FindFirstChild("Islands") then
        for _, island in pairs(workspace.Islands:GetChildren()) do
            table.insert(islandList, island.Name)
        end
    end
    
    if #islandList == 0 then
        table.insert(islandList, "No Islands Found")
    end
    
    return islandList
end

-- Variable para isla seleccionada
local currentSelectedIsland = ""


-- TAB MAIN - Solo 3 elementos
-- 1. Estado de Pelis - Corregir t√≠tulo

local link = "discord.gg/yWmNNmffgq"

local tabGroups = {
	TabGroup1 = Window:TabGroup()
}

local tabs = {
	Welcome = tabGroups.TabGroup1:Tab({ Name = "Welcome", Image = "rbxassetid://18821914323" }),
    Main = tabGroups.TabGroup1:Tab({ Name = "Farms", Image = "rbxassetid://18821914323" }),
    teleports = tabGroups.TabGroup1:Tab({ Name = "Teleports", Image = "rbxassetid://18821914323" }),
    misc = tabGroups.TabGroup1:Tab({ Name = "Misc", Image = "rbxassetid://18821914323" }),
	Settings = tabGroups.TabGroup1:Tab({ Name = "Settings", Image = "rbxassetid://10734950309" })
}

local sections = {
    welcomeSection = tabs.Welcome:Section({ Side = "Left" }),
    welcomeSectionDiscord = tabs.Welcome:Section({ Side = "right" }),
    welcomeSectionDevs = tabs.Welcome:Section({ Side = "right" }),
    welcomeSectionFarmsStatus = tabs.Welcome:Section({ Side = "Left" }),
    welcomeSectionFarmAnniversary = tabs.Main:Section({ Side = "right" }),
	MainSection1 = tabs.Main:Section({ Side = "Left" }),
    teleports = tabs.teleports:Section({ Side = "Left" }),
    teleportsMain = tabs.teleports:Section({ Side = "right" }),
    priv = tabs.misc:Section({ Side = "Left" }),
}

sections.welcomeSection:Header({
	Name = "Welcome to Ousi.HUB!"
})

sections.welcomeSection:Paragraph({
	Header = "Join to our Discord server!",
	Body = "discord.gg/yWmNNmffgq <- JOIN"
})

sections.welcomeSectionDiscord:Button({
	Name = "Copy discord link :)",
	Callback = function()
		setclipboard(link)
	end,
})
sections.priv:Button({
	Name = "Buy geppo",
	Callback = function()
		local args = {
            [1] = "skyWalkTrainer"
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("learnStyle"):FireServer(unpack(args))
	end,
})

sections.welcomeSectionDevs:Header({
	Name = "Script DEVELOPERS",
})

sections.welcomeSectionDevs:Label({
	Text = "-(((KOKIüíñ)))"
})
sections.welcomeSectionDevs:Label({
	Text = "-????"
})

sections.welcomeSectionFarmsStatus:Header({
	Name = "Script status",
})

sections.welcomeSectionFarmsStatus:Paragraph({
	Header = "Kaitun Status->‚úÖ",
	Body = "Working good!:)"
})



sections.welcomeSectionFarmsStatus:Paragraph({
	Header = "Anniversary Status->üü¶",
	Body = "Open Test!"
})

sections.welcomeSectionFarmsStatus:Paragraph({
	Header = "Cupid Status->üüß",
	Body = "In progress!"
})








sections.MainSection1:Header({
	Name = "AutoLevel Kaitun",
})

-- Sistema de notificaciones de depuraci√≥n que se muestran solo una vez
local debugNotifications = {}

-- Funci√≥n para mostrar notificaciones de depuraci√≥n solo una vez
local function debugNotify(id, title, description, lifetime)
    if not debugNotifications[id] then
        Window:Notify({
            Title = title or "Debug",
            Description = description or "",
            Lifetime = lifetime or 3
        })
        debugNotifications[id] = true
    end
end



-- Store the reference to the Paragraph element
local RifleStatus = sections.MainSection1:Paragraph({
	Header = "Rifle?",
	Body = "Loading..."
})

local PeliStatus = sections.MainSection1:Paragraph({
	Header = "Peli?",
	Body = "Loading..."
})

sections.MainSection1:Toggle({
	Name = "Kaitun",
	Default = false,
	Callback = function(value)
        print(value)
		_G.KaitunActive = value
		Window:Notify({
			Title = "Ousi.HUB",
			Description = (value and "Enabled " or "Disabled ") .. "AutloLevel Kaitun"
		})
	end,
}, "KaitunToggle")



-- Set up a proper timer to call the update function periodically




sections.welcomeSectionFarmAnniversary:Header({
	Name = "AutoAnniversary",
})

local megaStatus = sections.welcomeSectionFarmAnniversary:Paragraph({
	Header = "Mega-Pow?",
	Body = "‚úÖ"
})

if debug then

    waveParagraph = sections.welcomeSectionFarmAnniversary:Paragraph({
        Header = "Control de Waves",
        Body = "Wave " .. tostring(wave) .. "!"
    })


    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 1",
        Callback = function()
            wave = 1
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 1!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 1",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 2",
        Callback = function()
            wave = 2
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 2!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 2",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 3",
        Callback = function()
            wave = 3
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 3!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 3",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 4",
        Callback = function()
            wave = 4
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 4!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 4",
                Lifetime = 3
            })
            end
        end
    })

    sections.welcomeSectionFarmAnniversary:Button({
        Name = "wave 5",
        Callback = function()
            wave = 5
            if waveParagraph then
                waveParagraph:UpdateBody("Wave 5!")
            end
            if debug then
                Window:Notify({
                Title = "Cambio manual",
                Description = "Cambiando a Wave 5",
                Lifetime = 3
            })
            end
        end
    })
end

task.spawn(function()
    while true do
        local success, err = pcall(function()
            local hasRifle = checkGun()
            local hasMega = checkMega()
            local peliAmount = checkPeli()
            
            if debug then
                print("Iteraci√≥n de actualizaci√≥n:", hasRifle, peliAmount, hasMega)  -- Depuraci√≥n
            end

            RifleStatus:UpdateBody(hasRifle and "‚úÖ Equipped" or "‚ùå Not Equipped")
            megaStatus:UpdateBody(hasMega and "‚úÖ Equipped" or "‚ùå Not Equipped")

            
            local peliDisplay = "‚ùå no peli for rifle"
            if type(peliAmount) == "number" and peliAmount >= 300 then
                peliDisplay = "‚úÖ " .. peliAmount .. " Peli"
            end
            PeliStatus:UpdateBody(peliDisplay)
            
            if not hasUpdatedOnce then
                if debug then
                    debugNotify("first_auto_update", "Auto Update", 
                        "First auto update completed. Rifle: " .. (hasRifle and "Yes" or "No") ..
                        ", Peli: " .. (type(peliAmount) == "number" and peliAmount or "N/A"), 3)
                end
                hasUpdatedOnce = true
            end
        end)
        if not success then
            warn("Error en la actualizaci√≥n autom√°tica:", err)
        end
        
        task.wait(2)
    end
end)





sections.welcomeSectionFarmAnniversary:Toggle({
    Name = "Anniversary",
    Default = false,
    Callback = function(value)
        farm = value
        print(farm)
        if farm then

            





            local function gpo()
                local args = {
                    [1] = "Sky Walk2",
                    [2] = {
                        ["char"] = game.Players.LocalPlayer.Character,
                        ["cf"] = CFrame.new(-6629.06103515625, 17.600412368774414, -4605.69873046875, 0, 1, -0, 0, -0, -1, -1, 0, -0)
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Skill"):InvokeServer(unpack(args))
            end
            
            local gpoRunning = false
            local function startGpoContinuous()
                if gpoRunning then return end
                gpoRunning = true
                
                task.spawn(function()
                    while farm do
                        pcall(function() gpo() end)
                        wait(2)
                    end
                    gpoRunning = false
                end)
            end

            -- Iniciar el Sky Walk2 continuo
            startGpoContinuous()
            
            if game.PlaceId == 3978370137 then
                tween(Vector3.new(-6570, 11, -4599))
            else 
                StartFarm()
            end
        else
            -- Desconectar Heartbeat al desactivar el toggle
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
            
            if debug then
                print("Control de Waves desactivado")
            end
        end
    end,
}, "Anniversary")




sections.teleports:Header({
	Name = "Teleport to islands",
})

local islandDropdown = sections.teleports:Dropdown({
    Name = "Teleports",
    Search = true,
    Options = getIslands(),
    Callback = function(Value)
        -- For single selection dropdowns, Value is the selected option name
        currentSelectedIsland = Value
        
        -- Optional: Show notification when island is selected
        Window:Notify({
            Title = "Island Selected",
            Description = "Selected: " .. Value,
            Lifetime = 2
        })
    end,
})

sections.teleports:Button({
	Name = "Teleport to island",
	Callback = function()
		if currentSelectedIsland and currentSelectedIsland ~= "" and currentSelectedIsland ~= "No Islands Found" then
            local targetIsland = workspace.Islands:FindFirstChild(currentSelectedIsland)
            if targetIsland then
                -- Notificar al usuario
                Window:Notify({
                    Title = "Teleport",
                    Description = "Teleporting to " .. currentSelectedIsland,
                    Lifetime = 3
                })
                
                -- Obtener posici√≥n de la isla usando atributos
                local islandPosition = nil
                
                -- Usar pcall para evitar errores al obtener atributos
                pcall(function()
                    -- Comprobar islandCFrame (puede ser CFrame o string)
                    local islandCFrameAttr = targetIsland:GetAttribute("islandCFrame")
                    if islandCFrameAttr then
                        -- Si es un CFrame directo
                        if typeof(islandCFrameAttr) == "CFrame" then
                            islandPosition = islandCFrameAttr.Position
                        -- Si es un string que representa coordenadas
                        elseif typeof(islandCFrameAttr) == "string" then
                            local x, y, z = string.match(islandCFrameAttr, "(-?%d+%.?%d*),? *(-?%d+%.?%d*),? *(-?%d+%.?%d*)")
                            if x and y and z then
                                islandPosition = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                            end
                        end
                    end
                    
                    -- Si no se pudo obtener con islandCFrame, intentar con islandPosition
                    if not islandPosition then
                        local islandPosAttr = targetIsland:GetAttribute("islandPosition")
                        if islandPosAttr then
                            -- Si es un Vector3 directo
                            if typeof(islandPosAttr) == "Vector3" then
                                islandPosition = islandPosAttr
                            -- Si es un string que representa coordenadas
                            elseif typeof(islandPosAttr) == "string" then
                                local x, y, z = string.match(islandPosAttr, "(-?%d+%.?%d*),? *(-?%d+%.?%d*),? *(-?%d+%.?%d*)")
                                if x and y and z then
                                    islandPosition = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                                end
                            end
                        end
                    end
                    
                    -- Si no se pudo obtener con atributos, intentar con WorldPivot
                    if not islandPosition then
                        local worldPivot = targetIsland:GetPivot()
                        islandPosition = worldPivot.Position
                    end
                end)
                
                -- Si a√∫n no tenemos posici√≥n, buscar en PrimaryPart o cualquier parte
                if not islandPosition then
                    pcall(function()
                        if targetIsland.PrimaryPart then
                            islandPosition = targetIsland.PrimaryPart.Position
                        else
                            -- Buscar cualquier parte y usar su posici√≥n
                            for _, part in pairs(targetIsland:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    islandPosition = part.Position
                                    break
                                end
                            end
                        end
                    end)
                end
                
                -- Verificar que tenemos una posici√≥n v√°lida
                if islandPosition then
                    -- Poner offset en Y para evitar quedar dentro del terreno
                    local finalPos = Vector3.new(islandPosition.X, islandPosition.Y + 1000, islandPosition.Z)
                    
                    -- Usar la estructura exacta solicitada
                    pcall(function()
                        player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                        task.wait(0.1) -- Peque√±a pausa para estabilizar
                        
                        -- Reset del personaje
                        ReplicatedStorage:WaitForChild("Events"):WaitForChild("KnockedOut"):FireServer("self")
                        task.wait(0.3) -- Esperar despu√©s del KnockedOut
                        
                        -- Notificar al usuario
                        Window:Notify({
                            Title = "Teleport + Reset",
                            Description = "Teleport to " .. currentSelectedIsland .. " completed",
                            Lifetime = 2
                        })
                    end)
                else
                    Window:Notify({
                        Title = "Teleport error",
                        Description = "Island not found in workspace",
                        Lifetime = 3
                    })
                end
            else
                Window:Notify({
                    Title = "Teleport error",
                    Description = "Island not found in workspace",
                    Lifetime = 3
                })
            end
        else
            Window:Notify({
                Title = "Teleport error",
                Description = "Please select an island first",
                Lifetime = 3
            })
        end
	end,
})

sections.teleportsMain:Header({
	Name = "Teleport to main game",
})

sections.teleportsMain:Button({
	Name = "Teleport to main game",
	Callback = function()

        local TeleportService = game:GetService("TeleportService")
        local placeId = 3978370137
        TeleportService:Teleport(placeId)
    end
})

sections.teleportsMain:Button({
	Name = "Teleport to main menu",
	Callback = function()

        local TeleportService = game:GetService("TeleportService")
        local placeId = 1730877806
        TeleportService:Teleport(placeId)
    end
})



-- A√±adimos las funciones para cofres
local TweenService = game:GetService("TweenService")

-- Versi√≥n optimizada con tweens basados en velocidad constante de 35

-- Funci√≥n para encontrar el cofre m√°s cercano y evitar repetici√≥n
local coffresUsados = {}  -- Tabla para rastrear cofres ya usados

local function findNearestChest()
    local nearestChest = nil
    local minDistance = math.huge
    
    -- Buscar cofres en workspace.Env
    if workspace:FindFirstChild("Env") then
        for _, v in pairs(workspace.Env:GetDescendants()) do
            if v.Name == "Chest" or v.Name:lower():find("chest") or v.Name:lower():find("cofre") then
                -- Verificar si ya fue usado
                if not coffresUsados[v] and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (v:GetPivot().Position - player.Character.HumanoidRootPart.Position).Magnitude
                    if distance < minDistance then
                        minDistance = distance
                        nearestChest = v
                    end
                end
            end
        end
    end
    
    return nearestChest
end

-- Funci√≥n para interactuar con prompts cercanos
local function interactWithPromptOnce()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    
    local humanoidRootPart = player.Character.HumanoidRootPart
    local interacted = false
    
    for _, prompt in pairs(workspace:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") and prompt.Name == "ProximityPrompt" then
            local distance = (prompt.Parent:IsA("Part") and (prompt.Parent.Position - humanoidRootPart.Position).Magnitude or math.huge)
            if distance <= 5 and prompt.Enabled then
                fireproximityprompt(prompt, prompt.HoldDuration)

                interacted = true
                break
            end
        end
    end
    
    return interacted
end

-- Funci√≥n optimizada para moverse a cofres con velocidad constante
local function tweenToChest(chest)
    if not chest or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    
    -- Crear BodyVelocity para no caer
    local bv = Instance.new("BodyVelocity")
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Parent = player.Character.HumanoidRootPart
    
    -- Primera etapa: TP directo a Y=200 (misma XZ)
    local currentPos = player.Character.HumanoidRootPart.Position
    local highPos = Vector3.new(currentPos.X, 15, currentPos.Z)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(highPos)
    task.wait(0.1)  -- Peque√±a pausa para estabilizar
    
    -- Segunda etapa: tween a XZ del cofre a velocidad constante de 35
    local chestPos = chest:GetPivot().Position
    local targetPosXZ = Vector3.new(chestPos.X, 15, chestPos.Z)
    
    -- Calcular duraci√≥n basada en velocidad constante de 35
    local duracion = calcularDuracionTween(highPos, targetPosXZ, 35)
    
    local tweenInfoXZ = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
    local tweenXZ = createTween(player.Character.HumanoidRootPart, tweenInfoXZ, {CFrame = CFrame.new(targetPosXZ)}, true)
    
    tweenXZ:Play()
    tweenXZ.Completed:Wait()
    
    -- Tercera etapa: TP directo a Y+3 del cofre
    local finalPos = Vector3.new(chestPos.X, chestPos.Y + 3, chestPos.Z)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
    
    -- Activar ProximityPrompt 
    task.wait(0.3)
    local success = interactWithPromptOnce()
    
    -- Marcar el cofre como usado si tuvimos √©xito
    if success then
        coffresUsados[chest] = true
    end
    
    -- Eliminar BodyVelocity
    task.wait(0.5)  -- Reducido tiempo de espera
    if bv and bv.Parent then
        bv:Destroy()
    end
    
    return success
end

-- Nueva funci√≥n para comprar el rifle desde la tienda
local function buyRifleFromShop()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    
    -- Crear BodyVelocity para no caer
    local bv = Instance.new("BodyVelocity")
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Parent = player.Character.HumanoidRootPart
    
    -- Tween para subir a Y=200 (en lugar de TP directo)
    local currentPos = player.Character.HumanoidRootPart.Position
    local elevatedPos = Vector3.new(currentPos.X, 15, currentPos.Z)
    
    -- Calcular duraci√≥n para el tween vertical (velocidad 20)
    local verticalDistance = math.abs(currentPos.Y - 200)
    local verticalDuration = verticalDistance / 20
    
    local tweenInfoY = TweenInfo.new(verticalDuration, Enum.EasingStyle.Linear)
    local tweenY = createTween(player.Character.HumanoidRootPart, tweenInfoY, {CFrame = CFrame.new(elevatedPos)}, false)
    
    tweenY:Play()
    tweenY.Completed:Wait()
    task.wait(0.1)  -- Peque√±a pausa para estabilizar
    
    -- Tween a las coordenadas (-531, 200, -3448) con velocidad constante
    local storeXZ = Vector3.new(-531, 15, -3448)
    local duracion = calcularDuracionTween(elevatedPos, storeXZ, 35)
    local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
    local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
    
    tweenStore:Play()
    tweenStore.Completed:Wait()
    
    -- Tween para bajar a Y=6 (en lugar de TP directo)
    local finalPos = Vector3.new(-531, 6, -3448)
    
    -- Calcular duraci√≥n para el tween vertical de bajada (velocidad 20)
    local descendDistance = math.abs(200 - 6)
    local descendDuration = descendDistance / 20
    
    local tweenInfoDescend = TweenInfo.new(descendDuration, Enum.EasingStyle.Linear)
    local tweenDescend = createTween(player.Character.HumanoidRootPart, tweenInfoDescend, {CFrame = CFrame.new(finalPos)}, false)
    
    tweenDescend:Play()
    tweenDescend.Completed:Wait()
    
    -- Eliminar BodyVelocity
    if bv and bv.Parent then
        bv:Destroy()
    end
    
    task.wait(0.3)
    
    return checkGun()
end

-- Funci√≥n corregida para comprar rifle (tween a XZ de la tienda, luego TP a Y+6)
local function buyAndEquipRifle()
    for i = 1, 5 do
        local args = {
            [1] = "equip",
            [2] = "Rifle"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Tools"):InvokeServer(unpack(args))
        task.wait(0.3)
    end
    return checkGun()
end

-- Nueva funci√≥n para comprar el rifle desde la tienda
local function buyRifleFromShop()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    local currentPos = player.Character.HumanoidRootPart.Position
    local storeXZ = Vector3.new(-531, 15, -3448)
    local duracion = calcularDuracionTween(currentPos, storeXZ, 35)
    local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
    local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
    tweenStore:Play()
    tweenStore.Completed:Wait()
    
    -- Teletransportar a Y=200 instant√°neamente
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local currentPos = player.Character.HumanoidRootPart.Position
        local bv = Instance.new("BodyVelocity")
        bv.Velocity = Vector3.new(0, 0, 0)
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = player.Character.HumanoidRootPart
        player.Character.HumanoidRootPart.CFrame = CFrame.new(currentPos.X, 15, currentPos.Z)
        task.wait(0.1)
        
        -- Tween a las coordenadas (-531, 200, -3448) con velocidad constante
        local storeXZ = Vector3.new(-531, 15, -3448)
        local duracion = calcularDuracionTween(currentPos, storeXZ, 35)
        local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
        local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
        tweenStore:Play()
        tweenStore.Completed:Wait()
        
        -- Teletransportar a Y=6 una vez llegado
        local finalPos = Vector3.new(-531, 6, -3448)
        player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
        bv:Destroy()
        task.wait(0.3)
    end
    
    local args = {
        [1] = workspace:WaitForChild("BuyableItems"):WaitForChild("Rifle"),
        [2] = 1
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Shop"):InvokeServer(unpack(args))
    task.wait(0.3)
    return checkGun()
end

-- Modificaci√≥n en la l√≥gica principal del Kaitun
-- Reemplazo en la secci√≥n donde, tras recolectar 300 pelis, se intenta comprar el rifle
task.spawn(function()
    while task.wait(1) do      
        if _G.KaitunActive then
            -- Intentar equipar el rifle 3 veces
            for i = 1, 3 do
                local args = { [1] = "equip", [2] = "Rifle" }
                game:GetService("ReplicatedStorage"):WaitForChild("Events")
                    :WaitForChild("Tools"):InvokeServer(unpack(args))
                task.wait(0.3)
            end
            
            -- Verificar si ya tenemos rifle y pelis suficientes
            local currentPelis = checkPeli()
            if checkGun() and currentPelis >= 300 then
                teleportToRifleArea()
                startAutoShooting()
                cancelAllActiveTweens(true)
            elseif checkGun() then
                -- Si tenemos rifle pero no pelis, ir directo a farmear
                teleportToRifleArea()
                startAutoShooting()
                cancelAllActiveTweens(true)
            else
                Window:Notify({
                    Title = "Kaitun Active",
                    Description = "Rifle not equipped, starting to farm Pelis...",
                    Lifetime = 2
                })
                
                -- Farmear cofres hasta tener 300 pelis
                while checkPeli() < 300 do
                    local nearestChest = findNearestChest()
                    if nearestChest then
                        Window:Notify({
                            Title = "Auto Farm",
                            Description = "Found a chest! Moving to collect...",
                            Lifetime = 2
                        })
                        local successChest = tweenToChest(nearestChest)
                        if not successChest then
                            Window:Notify({
                                Title = "Auto Farm",
                                Description = "Unable to collect chest, searching for another...",
                                Lifetime = 2
                            })
                            task.wait(2)
                        end
                    else
                        Window:Notify({
                            Title = "Auto Farm",
                            Description = "No chests found nearby. Searching...",
                            Lifetime = 3
                        })
                        task.wait(3)
                    end
                end
                
                -- Con suficientes pelis, se procede al proceso de compra del rifle
                Window:Notify({
                    Title = "Auto Farm",
                    Description = "Currency collected! Moving to shop...",
                    Lifetime = 2
                })
                
                -- Teletransportar a Y=200 instant√°neamente
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local currentPos = player.Character.HumanoidRootPart.Position
                    local bv = Instance.new("BodyVelocity")
                    bv.Velocity = Vector3.new(0, 0, 0)
                    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    bv.Parent = player.Character.HumanoidRootPart
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(currentPos.X, 15, currentPos.Z)
                    task.wait(0.1)
                    
                    -- Tween a las coordenadas (-531, 200, -3448) con velocidad constante
                    local storeXZ = Vector3.new(-531, 15, -3448)
                    local duracion = calcularDuracionTween(currentPos, storeXZ, 35)
                    local tweenInfoStore = TweenInfo.new(duracion, Enum.EasingStyle.Linear)
                    local tweenStore = createTween(player.Character.HumanoidRootPart, tweenInfoStore, {CFrame = CFrame.new(storeXZ)}, true)
                    tweenStore:Play()
                    tweenStore.Completed:Wait()
                    
                    -- Teletransportar a Y=6 una vez llegado
                    local finalPos = Vector3.new(-531, 6, -3448)
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPos)
                    bv:Destroy()
                    task.wait(0.3)
                end
                
                -- Llamada al Shop para comprar el rifle 3 veces
                for j = 1, 3 do
                    local argsShop = { [1] = workspace:WaitForChild("BuyableItems"):WaitForChild("Rifle"), [2] = 1 }
                    game:GetService("ReplicatedStorage"):WaitForChild("Events")
                        :WaitForChild("Shop"):InvokeServer(unpack(argsShop))
                    task.wait(0.3)
                end
                
                -- Intentar equipar el rifle 3 veces
                for k = 1, 3 do
                    local argsEquip = { [1] = "equip", [2] = "Rifle" }
                    game:GetService("ReplicatedStorage"):WaitForChild("Events")
                        :WaitForChild("Tools"):InvokeServer(unpack(argsEquip))
                    task.wait(0.3)
                end
                
                if checkGun() then
                    Window:Notify({
                        Title = "Success",
                        Description = "Rifle acquired and equipped, teleporting...",
                        Lifetime = 3
                    })
                    task.wait(1)
                    teleportToRifleArea()
                    startAutoShooting()
                    cancelAllActiveTweens(true)
                else
                    Window:Notify({
                        Title = "Error",
                        Description = "Failed to acquire rifle",
                        Lifetime = 3
                    })
                end
            end
        end
        task.wait(1)
    end
end)

--[[





logica arriba







]]--






MacLib:SetFolder("gpo")
tabs.Settings:InsertConfigSection("Left")

Window.onUnloaded(function()
    _G.KaitunActive = false
	print("Unloaded!")
end)

tabs.Welcome:Select()
MacLib:LoadAutoLoadConfig()
